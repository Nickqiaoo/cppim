// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logic.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "logic.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace logic {

namespace {

const ::google::protobuf::Descriptor* PushMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushMsg_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PushMsg_Type_descriptor_ = NULL;
const ::google::protobuf::Descriptor* CloseReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CloseReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* CloseReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CloseReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* PingReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PingReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* PingReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PingReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConnectReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConnectReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConnectReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConnectReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisconnectReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisconnectReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* DisconnectReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DisconnectReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* HeartbeatReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HeartbeatReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* OnlineReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OnlineReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* OnlineReq_RoomCountEntry_descriptor_ = NULL;
const ::google::protobuf::Descriptor* OnlineReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OnlineReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* OnlineReply_AllRoomCountEntry_descriptor_ = NULL;
const ::google::protobuf::Descriptor* ReceiveReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReceiveReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* ReceiveReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ReceiveReply_reflection_ = NULL;
const ::google::protobuf::ServiceDescriptor* Logic_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_logic_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_logic_2eproto() {
  protobuf_AddDesc_logic_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "logic.proto");
  GOOGLE_CHECK(file != NULL);
  PushMsg_descriptor_ = file->message_type(0);
  static const int PushMsg_offsets_[7] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, operation_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, speed_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, server_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, room_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, msg_),
  };
  PushMsg_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushMsg_descriptor_,
      PushMsg::default_instance_,
      PushMsg_offsets_,
      -1,
      -1,
      -1,
      sizeof(PushMsg),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsg, _is_default_instance_));
  PushMsg_Type_descriptor_ = PushMsg_descriptor_->enum_type(0);
  CloseReply_descriptor_ = file->message_type(1);
  static const int CloseReply_offsets_[1] = {
  };
  CloseReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CloseReply_descriptor_,
      CloseReply::default_instance_,
      CloseReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(CloseReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CloseReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CloseReply, _is_default_instance_));
  CloseReq_descriptor_ = file->message_type(2);
  static const int CloseReq_offsets_[1] = {
  };
  CloseReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      CloseReq_descriptor_,
      CloseReq::default_instance_,
      CloseReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(CloseReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CloseReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CloseReq, _is_default_instance_));
  PingReply_descriptor_ = file->message_type(3);
  static const int PingReply_offsets_[1] = {
  };
  PingReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PingReply_descriptor_,
      PingReply::default_instance_,
      PingReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(PingReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingReply, _is_default_instance_));
  PingReq_descriptor_ = file->message_type(4);
  static const int PingReq_offsets_[1] = {
  };
  PingReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PingReq_descriptor_,
      PingReq::default_instance_,
      PingReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(PingReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PingReq, _is_default_instance_));
  ConnectReq_descriptor_ = file->message_type(5);
  static const int ConnectReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReq, server_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReq, cookie_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReq, token_),
  };
  ConnectReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConnectReq_descriptor_,
      ConnectReq::default_instance_,
      ConnectReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(ConnectReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReq, _is_default_instance_));
  ConnectReply_descriptor_ = file->message_type(6);
  static const int ConnectReply_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, mid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, roomid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, accepts_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, heartbeat_),
  };
  ConnectReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ConnectReply_descriptor_,
      ConnectReply::default_instance_,
      ConnectReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(ConnectReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConnectReply, _is_default_instance_));
  DisconnectReq_descriptor_ = file->message_type(7);
  static const int DisconnectReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReq, mid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReq, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReq, server_),
  };
  DisconnectReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DisconnectReq_descriptor_,
      DisconnectReq::default_instance_,
      DisconnectReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(DisconnectReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReq, _is_default_instance_));
  DisconnectReply_descriptor_ = file->message_type(8);
  static const int DisconnectReply_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReply, has_),
  };
  DisconnectReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      DisconnectReply_descriptor_,
      DisconnectReply::default_instance_,
      DisconnectReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(DisconnectReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DisconnectReply, _is_default_instance_));
  HeartbeatReq_descriptor_ = file->message_type(9);
  static const int HeartbeatReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, mid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, server_),
  };
  HeartbeatReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatReq_descriptor_,
      HeartbeatReq::default_instance_,
      HeartbeatReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(HeartbeatReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReq, _is_default_instance_));
  HeartbeatReply_descriptor_ = file->message_type(10);
  static const int HeartbeatReply_offsets_[1] = {
  };
  HeartbeatReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      HeartbeatReply_descriptor_,
      HeartbeatReply::default_instance_,
      HeartbeatReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(HeartbeatReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HeartbeatReply, _is_default_instance_));
  OnlineReq_descriptor_ = file->message_type(11);
  static const int OnlineReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReq, server_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReq, roomcount_),
  };
  OnlineReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OnlineReq_descriptor_,
      OnlineReq::default_instance_,
      OnlineReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(OnlineReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReq, _is_default_instance_));
  OnlineReq_RoomCountEntry_descriptor_ = OnlineReq_descriptor_->nested_type(0);
  OnlineReply_descriptor_ = file->message_type(12);
  static const int OnlineReply_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReply, allroomcount_),
  };
  OnlineReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      OnlineReply_descriptor_,
      OnlineReply::default_instance_,
      OnlineReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(OnlineReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OnlineReply, _is_default_instance_));
  OnlineReply_AllRoomCountEntry_descriptor_ = OnlineReply_descriptor_->nested_type(0);
  ReceiveReq_descriptor_ = file->message_type(13);
  static const int ReceiveReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReq, mid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReq, proto_),
  };
  ReceiveReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReceiveReq_descriptor_,
      ReceiveReq::default_instance_,
      ReceiveReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(ReceiveReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReq, _is_default_instance_));
  ReceiveReply_descriptor_ = file->message_type(14);
  static const int ReceiveReply_offsets_[1] = {
  };
  ReceiveReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      ReceiveReply_descriptor_,
      ReceiveReply::default_instance_,
      ReceiveReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(ReceiveReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ReceiveReply, _is_default_instance_));
  Logic_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_logic_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushMsg_descriptor_, &PushMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CloseReply_descriptor_, &CloseReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      CloseReq_descriptor_, &CloseReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PingReply_descriptor_, &PingReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PingReq_descriptor_, &PingReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConnectReq_descriptor_, &ConnectReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ConnectReply_descriptor_, &ConnectReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DisconnectReq_descriptor_, &DisconnectReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      DisconnectReply_descriptor_, &DisconnectReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatReq_descriptor_, &HeartbeatReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      HeartbeatReply_descriptor_, &HeartbeatReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OnlineReq_descriptor_, &OnlineReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        OnlineReq_RoomCountEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::google::protobuf::int32,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
            0>::CreateDefaultInstance(
                OnlineReq_RoomCountEntry_descriptor_));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      OnlineReply_descriptor_, &OnlineReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        OnlineReply_AllRoomCountEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            ::google::protobuf::int32,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
            0>::CreateDefaultInstance(
                OnlineReply_AllRoomCountEntry_descriptor_));
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReceiveReq_descriptor_, &ReceiveReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      ReceiveReply_descriptor_, &ReceiveReply::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_logic_2eproto() {
  delete PushMsg::default_instance_;
  delete PushMsg_reflection_;
  delete CloseReply::default_instance_;
  delete CloseReply_reflection_;
  delete CloseReq::default_instance_;
  delete CloseReq_reflection_;
  delete PingReply::default_instance_;
  delete PingReply_reflection_;
  delete PingReq::default_instance_;
  delete PingReq_reflection_;
  delete ConnectReq::default_instance_;
  delete ConnectReq_reflection_;
  delete ConnectReply::default_instance_;
  delete ConnectReply_reflection_;
  delete DisconnectReq::default_instance_;
  delete DisconnectReq_reflection_;
  delete DisconnectReply::default_instance_;
  delete DisconnectReply_reflection_;
  delete HeartbeatReq::default_instance_;
  delete HeartbeatReq_reflection_;
  delete HeartbeatReply::default_instance_;
  delete HeartbeatReply_reflection_;
  delete OnlineReq::default_instance_;
  delete OnlineReq_reflection_;
  delete OnlineReply::default_instance_;
  delete OnlineReply_reflection_;
  delete ReceiveReq::default_instance_;
  delete ReceiveReq_reflection_;
  delete ReceiveReply::default_instance_;
  delete ReceiveReply_reflection_;
}

void protobuf_AddDesc_logic_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_logic_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::gate::protobuf_AddDesc_gate_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\013logic.proto\022\005logic\032\ngate.proto\"\262\001\n\007Pus"
    "hMsg\022!\n\004type\030\001 \001(\0162\023.logic.PushMsg.Type\022"
    "\021\n\toperation\030\002 \001(\005\022\r\n\005speed\030\003 \001(\005\022\016\n\006ser"
    "ver\030\004 \001(\t\022\014\n\004room\030\005 \001(\t\022\014\n\004keys\030\006 \003(\t\022\013\n"
    "\003msg\030\007 \001(\014\")\n\004Type\022\010\n\004PUSH\020\000\022\010\n\004ROOM\020\001\022\r"
    "\n\tBROADCAST\020\002\"\014\n\nCloseReply\"\n\n\010CloseReq\""
    "\013\n\tPingReply\"\t\n\007PingReq\";\n\nConnectReq\022\016\n"
    "\006server\030\001 \001(\t\022\016\n\006cookie\030\002 \001(\t\022\r\n\005token\030\003"
    " \001(\014\"\\\n\014ConnectReply\022\013\n\003mid\030\001 \001(\003\022\013\n\003key"
    "\030\002 \001(\t\022\016\n\006roomID\030\003 \001(\t\022\017\n\007accepts\030\004 \003(\005\022"
    "\021\n\theartbeat\030\005 \001(\003\"9\n\rDisconnectReq\022\013\n\003m"
    "id\030\001 \001(\003\022\013\n\003key\030\002 \001(\t\022\016\n\006server\030\003 \001(\t\"\036\n"
    "\017DisconnectReply\022\013\n\003has\030\001 \001(\010\"8\n\014Heartbe"
    "atReq\022\013\n\003mid\030\001 \001(\003\022\013\n\003key\030\002 \001(\t\022\016\n\006serve"
    "r\030\003 \001(\t\"\020\n\016HeartbeatReply\"\201\001\n\tOnlineReq\022"
    "\016\n\006server\030\001 \001(\t\0222\n\troomCount\030\002 \003(\0132\037.log"
    "ic.OnlineReq.RoomCountEntry\0320\n\016RoomCount"
    "Entry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\005:\0028\001\"~\n"
    "\013OnlineReply\022:\n\014allRoomCount\030\001 \003(\0132$.log"
    "ic.OnlineReply.AllRoomCountEntry\0323\n\021AllR"
    "oomCountEntry\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001("
    "\005:\0028\001\"5\n\nReceiveReq\022\013\n\003mid\030\001 \001(\003\022\032\n\005prot"
    "o\030\002 \001(\0132\013.gate.Proto\"\016\n\014ReceiveReply2\356\002\n"
    "\005Logic\022(\n\004Ping\022\016.logic.PingReq\032\020.logic.P"
    "ingReply\022+\n\005Close\022\017.logic.CloseReq\032\021.log"
    "ic.CloseReply\0221\n\007Connect\022\021.logic.Connect"
    "Req\032\023.logic.ConnectReply\022:\n\nDisconnect\022\024"
    ".logic.DisconnectReq\032\026.logic.DisconnectR"
    "eply\0227\n\tHeartbeat\022\023.logic.HeartbeatReq\032\025"
    ".logic.HeartbeatReply\0223\n\013RenewOnline\022\020.l"
    "ogic.OnlineReq\032\022.logic.OnlineReply\0221\n\007Re"
    "ceive\022\021.logic.ReceiveReq\032\023.logic.Receive"
    "ReplyB\003\200\001\001b\006proto3", 1298);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "logic.proto", &protobuf_RegisterTypes);
  PushMsg::default_instance_ = new PushMsg();
  CloseReply::default_instance_ = new CloseReply();
  CloseReq::default_instance_ = new CloseReq();
  PingReply::default_instance_ = new PingReply();
  PingReq::default_instance_ = new PingReq();
  ConnectReq::default_instance_ = new ConnectReq();
  ConnectReply::default_instance_ = new ConnectReply();
  DisconnectReq::default_instance_ = new DisconnectReq();
  DisconnectReply::default_instance_ = new DisconnectReply();
  HeartbeatReq::default_instance_ = new HeartbeatReq();
  HeartbeatReply::default_instance_ = new HeartbeatReply();
  OnlineReq::default_instance_ = new OnlineReq();
  OnlineReply::default_instance_ = new OnlineReply();
  ReceiveReq::default_instance_ = new ReceiveReq();
  ReceiveReply::default_instance_ = new ReceiveReply();
  PushMsg::default_instance_->InitAsDefaultInstance();
  CloseReply::default_instance_->InitAsDefaultInstance();
  CloseReq::default_instance_->InitAsDefaultInstance();
  PingReply::default_instance_->InitAsDefaultInstance();
  PingReq::default_instance_->InitAsDefaultInstance();
  ConnectReq::default_instance_->InitAsDefaultInstance();
  ConnectReply::default_instance_->InitAsDefaultInstance();
  DisconnectReq::default_instance_->InitAsDefaultInstance();
  DisconnectReply::default_instance_->InitAsDefaultInstance();
  HeartbeatReq::default_instance_->InitAsDefaultInstance();
  HeartbeatReply::default_instance_->InitAsDefaultInstance();
  OnlineReq::default_instance_->InitAsDefaultInstance();
  OnlineReply::default_instance_->InitAsDefaultInstance();
  ReceiveReq::default_instance_->InitAsDefaultInstance();
  ReceiveReply::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_logic_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_logic_2eproto {
  StaticDescriptorInitializer_logic_2eproto() {
    protobuf_AddDesc_logic_2eproto();
  }
} static_descriptor_initializer_logic_2eproto_;

// ===================================================================

const ::google::protobuf::EnumDescriptor* PushMsg_Type_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushMsg_Type_descriptor_;
}
bool PushMsg_Type_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const PushMsg_Type PushMsg::PUSH;
const PushMsg_Type PushMsg::ROOM;
const PushMsg_Type PushMsg::BROADCAST;
const PushMsg_Type PushMsg::Type_MIN;
const PushMsg_Type PushMsg::Type_MAX;
const int PushMsg::Type_ARRAYSIZE;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900
#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PushMsg::kTypeFieldNumber;
const int PushMsg::kOperationFieldNumber;
const int PushMsg::kSpeedFieldNumber;
const int PushMsg::kServerFieldNumber;
const int PushMsg::kRoomFieldNumber;
const int PushMsg::kKeysFieldNumber;
const int PushMsg::kMsgFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PushMsg::PushMsg()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.PushMsg)
}

void PushMsg::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PushMsg::PushMsg(const PushMsg& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.PushMsg)
}

void PushMsg::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  type_ = 0;
  operation_ = 0;
  speed_ = 0;
  server_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  room_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

PushMsg::~PushMsg() {
  // @@protoc_insertion_point(destructor:logic.PushMsg)
  SharedDtor();
}

void PushMsg::SharedDtor() {
  server_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  room_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void PushMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushMsg_descriptor_;
}

const PushMsg& PushMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

PushMsg* PushMsg::default_instance_ = NULL;

PushMsg* PushMsg::New(::google::protobuf::Arena* arena) const {
  PushMsg* n = new PushMsg;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushMsg::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.PushMsg)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(PushMsg, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<PushMsg*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(type_, operation_);
  speed_ = 0;
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  room_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

  keys_.Clear();
}

bool PushMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.PushMsg)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .logic.PushMsg.Type type = 1;
      case 1: {
        if (tag == 8) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          set_type(static_cast< ::logic::PushMsg_Type >(value));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_operation;
        break;
      }

      // optional int32 operation = 2;
      case 2: {
        if (tag == 16) {
         parse_operation:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &operation_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_speed;
        break;
      }

      // optional int32 speed = 3;
      case 3: {
        if (tag == 24) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_server;
        break;
      }

      // optional string server = 4;
      case 4: {
        if (tag == 34) {
         parse_server:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.PushMsg.server"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_room;
        break;
      }

      // optional string room = 5;
      case 5: {
        if (tag == 42) {
         parse_room:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_room()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->room().data(), this->room().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.PushMsg.room"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_keys;
        break;
      }

      // repeated string keys = 6;
      case 6: {
        if (tag == 50) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_keys()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->keys(this->keys_size() - 1).data(),
            this->keys(this->keys_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.PushMsg.keys"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_keys;
        if (input->ExpectTag(58)) goto parse_msg;
        break;
      }

      // optional bytes msg = 7;
      case 7: {
        if (tag == 58) {
         parse_msg:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_msg()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.PushMsg)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.PushMsg)
  return false;
#undef DO_
}

void PushMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.PushMsg)
  // optional .logic.PushMsg.Type type = 1;
  if (this->type() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // optional int32 operation = 2;
  if (this->operation() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->operation(), output);
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->speed(), output);
  }

  // optional string server = 4;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.server");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->server(), output);
  }

  // optional string room = 5;
  if (this->room().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->room().data(), this->room().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.room");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->room(), output);
  }

  // repeated string keys = 6;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->keys(i).data(), this->keys(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.keys");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      6, this->keys(i), output);
  }

  // optional bytes msg = 7;
  if (this->msg().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      7, this->msg(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.PushMsg)
}

::google::protobuf::uint8* PushMsg::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.PushMsg)
  // optional .logic.PushMsg.Type type = 1;
  if (this->type() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // optional int32 operation = 2;
  if (this->operation() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->operation(), target);
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->speed(), target);
  }

  // optional string server = 4;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.server");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->server(), target);
  }

  // optional string room = 5;
  if (this->room().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->room().data(), this->room().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.room");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->room(), target);
  }

  // repeated string keys = 6;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->keys(i).data(), this->keys(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.PushMsg.keys");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(6, this->keys(i), target);
  }

  // optional bytes msg = 7;
  if (this->msg().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        7, this->msg(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.PushMsg)
  return target;
}

int PushMsg::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.PushMsg)
  int total_size = 0;

  // optional .logic.PushMsg.Type type = 1;
  if (this->type() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
  }

  // optional int32 operation = 2;
  if (this->operation() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->operation());
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->speed());
  }

  // optional string server = 4;
  if (this->server().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->server());
  }

  // optional string room = 5;
  if (this->room().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->room());
  }

  // optional bytes msg = 7;
  if (this->msg().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->msg());
  }

  // repeated string keys = 6;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->keys(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushMsg::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.PushMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PushMsg* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushMsg>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.PushMsg)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.PushMsg)
    MergeFrom(*source);
  }
}

void PushMsg::MergeFrom(const PushMsg& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.PushMsg)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  keys_.MergeFrom(from.keys_);
  if (from.type() != 0) {
    set_type(from.type());
  }
  if (from.operation() != 0) {
    set_operation(from.operation());
  }
  if (from.speed() != 0) {
    set_speed(from.speed());
  }
  if (from.server().size() > 0) {

    server_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_);
  }
  if (from.room().size() > 0) {

    room_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.room_);
  }
  if (from.msg().size() > 0) {

    msg_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.msg_);
  }
}

void PushMsg::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.PushMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushMsg::CopyFrom(const PushMsg& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.PushMsg)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushMsg::IsInitialized() const {

  return true;
}

void PushMsg::Swap(PushMsg* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushMsg::InternalSwap(PushMsg* other) {
  std::swap(type_, other->type_);
  std::swap(operation_, other->operation_);
  std::swap(speed_, other->speed_);
  server_.Swap(&other->server_);
  room_.Swap(&other->room_);
  keys_.UnsafeArenaSwap(&other->keys_);
  msg_.Swap(&other->msg_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushMsg_descriptor_;
  metadata.reflection = PushMsg_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushMsg

// optional .logic.PushMsg.Type type = 1;
void PushMsg::clear_type() {
  type_ = 0;
}
 ::logic::PushMsg_Type PushMsg::type() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.type)
  return static_cast< ::logic::PushMsg_Type >(type_);
}
 void PushMsg::set_type(::logic::PushMsg_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.type)
}

// optional int32 operation = 2;
void PushMsg::clear_operation() {
  operation_ = 0;
}
 ::google::protobuf::int32 PushMsg::operation() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.operation)
  return operation_;
}
 void PushMsg::set_operation(::google::protobuf::int32 value) {
  
  operation_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.operation)
}

// optional int32 speed = 3;
void PushMsg::clear_speed() {
  speed_ = 0;
}
 ::google::protobuf::int32 PushMsg::speed() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.speed)
  return speed_;
}
 void PushMsg::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.speed)
}

// optional string server = 4;
void PushMsg::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PushMsg::server() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.server)
}
 void PushMsg::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.server)
}
 void PushMsg::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.server)
}
 ::std::string* PushMsg::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PushMsg::release_server() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.server)
}

// optional string room = 5;
void PushMsg::clear_room() {
  room_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PushMsg::room() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.room)
  return room_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_room(const ::std::string& value) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.room)
}
 void PushMsg::set_room(const char* value) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.room)
}
 void PushMsg::set_room(const char* value, size_t size) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.room)
}
 ::std::string* PushMsg::mutable_room() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.room)
  return room_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PushMsg::release_room() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.room)
  
  return room_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_allocated_room(::std::string* room) {
  if (room != NULL) {
    
  } else {
    
  }
  room_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.room)
}

// repeated string keys = 6;
int PushMsg::keys_size() const {
  return keys_.size();
}
void PushMsg::clear_keys() {
  keys_.Clear();
}
 const ::std::string& PushMsg::keys(int index) const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.keys)
  return keys_.Get(index);
}
 ::std::string* PushMsg::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.keys)
  return keys_.Mutable(index);
}
 void PushMsg::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:logic.PushMsg.keys)
  keys_.Mutable(index)->assign(value);
}
 void PushMsg::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.keys)
}
 void PushMsg::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.keys)
}
 ::std::string* PushMsg::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:logic.PushMsg.keys)
  return keys_.Add();
}
 void PushMsg::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:logic.PushMsg.keys)
}
 void PushMsg::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:logic.PushMsg.keys)
}
 void PushMsg::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:logic.PushMsg.keys)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
PushMsg::keys() const {
  // @@protoc_insertion_point(field_list:logic.PushMsg.keys)
  return keys_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
PushMsg::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:logic.PushMsg.keys)
  return &keys_;
}

// optional bytes msg = 7;
void PushMsg::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& PushMsg::msg() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.msg)
}
 void PushMsg::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.msg)
}
 void PushMsg::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.msg)
}
 ::std::string* PushMsg::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* PushMsg::release_msg() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void PushMsg::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.msg)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CloseReply::CloseReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.CloseReply)
}

void CloseReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

CloseReply::CloseReply(const CloseReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.CloseReply)
}

void CloseReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

CloseReply::~CloseReply() {
  // @@protoc_insertion_point(destructor:logic.CloseReply)
  SharedDtor();
}

void CloseReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CloseReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CloseReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CloseReply_descriptor_;
}

const CloseReply& CloseReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

CloseReply* CloseReply::default_instance_ = NULL;

CloseReply* CloseReply::New(::google::protobuf::Arena* arena) const {
  CloseReply* n = new CloseReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CloseReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.CloseReply)
}

bool CloseReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.CloseReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.CloseReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.CloseReply)
  return false;
#undef DO_
}

void CloseReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.CloseReply)
  // @@protoc_insertion_point(serialize_end:logic.CloseReply)
}

::google::protobuf::uint8* CloseReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.CloseReply)
  // @@protoc_insertion_point(serialize_to_array_end:logic.CloseReply)
  return target;
}

int CloseReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.CloseReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CloseReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.CloseReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CloseReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CloseReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.CloseReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.CloseReply)
    MergeFrom(*source);
  }
}

void CloseReply::MergeFrom(const CloseReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.CloseReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void CloseReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.CloseReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CloseReply::CopyFrom(const CloseReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.CloseReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseReply::IsInitialized() const {

  return true;
}

void CloseReply::Swap(CloseReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CloseReply::InternalSwap(CloseReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CloseReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CloseReply_descriptor_;
  metadata.reflection = CloseReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CloseReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

CloseReq::CloseReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.CloseReq)
}

void CloseReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

CloseReq::CloseReq(const CloseReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.CloseReq)
}

void CloseReq::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

CloseReq::~CloseReq() {
  // @@protoc_insertion_point(destructor:logic.CloseReq)
  SharedDtor();
}

void CloseReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CloseReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CloseReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CloseReq_descriptor_;
}

const CloseReq& CloseReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

CloseReq* CloseReq::default_instance_ = NULL;

CloseReq* CloseReq::New(::google::protobuf::Arena* arena) const {
  CloseReq* n = new CloseReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void CloseReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.CloseReq)
}

bool CloseReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.CloseReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.CloseReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.CloseReq)
  return false;
#undef DO_
}

void CloseReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.CloseReq)
  // @@protoc_insertion_point(serialize_end:logic.CloseReq)
}

::google::protobuf::uint8* CloseReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.CloseReq)
  // @@protoc_insertion_point(serialize_to_array_end:logic.CloseReq)
  return target;
}

int CloseReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.CloseReq)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CloseReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.CloseReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const CloseReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const CloseReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.CloseReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.CloseReq)
    MergeFrom(*source);
  }
}

void CloseReq::MergeFrom(const CloseReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.CloseReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void CloseReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.CloseReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CloseReq::CopyFrom(const CloseReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.CloseReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CloseReq::IsInitialized() const {

  return true;
}

void CloseReq::Swap(CloseReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void CloseReq::InternalSwap(CloseReq* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata CloseReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CloseReq_descriptor_;
  metadata.reflection = CloseReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// CloseReq

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PingReply::PingReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.PingReply)
}

void PingReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PingReply::PingReply(const PingReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.PingReply)
}

void PingReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

PingReply::~PingReply() {
  // @@protoc_insertion_point(destructor:logic.PingReply)
  SharedDtor();
}

void PingReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PingReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PingReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PingReply_descriptor_;
}

const PingReply& PingReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

PingReply* PingReply::default_instance_ = NULL;

PingReply* PingReply::New(::google::protobuf::Arena* arena) const {
  PingReply* n = new PingReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PingReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.PingReply)
}

bool PingReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.PingReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.PingReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.PingReply)
  return false;
#undef DO_
}

void PingReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.PingReply)
  // @@protoc_insertion_point(serialize_end:logic.PingReply)
}

::google::protobuf::uint8* PingReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.PingReply)
  // @@protoc_insertion_point(serialize_to_array_end:logic.PingReply)
  return target;
}

int PingReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.PingReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.PingReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PingReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PingReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.PingReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.PingReply)
    MergeFrom(*source);
  }
}

void PingReply::MergeFrom(const PingReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.PingReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void PingReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.PingReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PingReply::CopyFrom(const PingReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.PingReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingReply::IsInitialized() const {

  return true;
}

void PingReply::Swap(PingReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PingReply::InternalSwap(PingReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PingReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PingReply_descriptor_;
  metadata.reflection = PingReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PingReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PingReq::PingReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.PingReq)
}

void PingReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PingReq::PingReq(const PingReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.PingReq)
}

void PingReq::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

PingReq::~PingReq() {
  // @@protoc_insertion_point(destructor:logic.PingReq)
  SharedDtor();
}

void PingReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PingReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PingReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PingReq_descriptor_;
}

const PingReq& PingReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

PingReq* PingReq::default_instance_ = NULL;

PingReq* PingReq::New(::google::protobuf::Arena* arena) const {
  PingReq* n = new PingReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PingReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.PingReq)
}

bool PingReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.PingReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.PingReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.PingReq)
  return false;
#undef DO_
}

void PingReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.PingReq)
  // @@protoc_insertion_point(serialize_end:logic.PingReq)
}

::google::protobuf::uint8* PingReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.PingReq)
  // @@protoc_insertion_point(serialize_to_array_end:logic.PingReq)
  return target;
}

int PingReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.PingReq)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PingReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.PingReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PingReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PingReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.PingReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.PingReq)
    MergeFrom(*source);
  }
}

void PingReq::MergeFrom(const PingReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.PingReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void PingReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.PingReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PingReq::CopyFrom(const PingReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.PingReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PingReq::IsInitialized() const {

  return true;
}

void PingReq::Swap(PingReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PingReq::InternalSwap(PingReq* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PingReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PingReq_descriptor_;
  metadata.reflection = PingReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PingReq

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConnectReq::kServerFieldNumber;
const int ConnectReq::kCookieFieldNumber;
const int ConnectReq::kTokenFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConnectReq::ConnectReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.ConnectReq)
}

void ConnectReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ConnectReq::ConnectReq(const ConnectReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.ConnectReq)
}

void ConnectReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  server_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cookie_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  token_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

ConnectReq::~ConnectReq() {
  // @@protoc_insertion_point(destructor:logic.ConnectReq)
  SharedDtor();
}

void ConnectReq::SharedDtor() {
  server_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cookie_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  token_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ConnectReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConnectReq_descriptor_;
}

const ConnectReq& ConnectReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

ConnectReq* ConnectReq::default_instance_ = NULL;

ConnectReq* ConnectReq::New(::google::protobuf::Arena* arena) const {
  ConnectReq* n = new ConnectReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConnectReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.ConnectReq)
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cookie_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool ConnectReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.ConnectReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string server = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.ConnectReq.server"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_cookie;
        break;
      }

      // optional string cookie = 2;
      case 2: {
        if (tag == 18) {
         parse_cookie:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cookie()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->cookie().data(), this->cookie().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.ConnectReq.cookie"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_token;
        break;
      }

      // optional bytes token = 3;
      case 3: {
        if (tag == 26) {
         parse_token:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_token()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.ConnectReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.ConnectReq)
  return false;
#undef DO_
}

void ConnectReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.ConnectReq)
  // optional string server = 1;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReq.server");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->server(), output);
  }

  // optional string cookie = 2;
  if (this->cookie().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cookie().data(), this->cookie().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReq.cookie");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->cookie(), output);
  }

  // optional bytes token = 3;
  if (this->token().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->token(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.ConnectReq)
}

::google::protobuf::uint8* ConnectReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.ConnectReq)
  // optional string server = 1;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReq.server");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->server(), target);
  }

  // optional string cookie = 2;
  if (this->cookie().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cookie().data(), this->cookie().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReq.cookie");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->cookie(), target);
  }

  // optional bytes token = 3;
  if (this->token().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        3, this->token(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.ConnectReq)
  return target;
}

int ConnectReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.ConnectReq)
  int total_size = 0;

  // optional string server = 1;
  if (this->server().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->server());
  }

  // optional string cookie = 2;
  if (this->cookie().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cookie());
  }

  // optional bytes token = 3;
  if (this->token().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->token());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.ConnectReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ConnectReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConnectReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.ConnectReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.ConnectReq)
    MergeFrom(*source);
  }
}

void ConnectReq::MergeFrom(const ConnectReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.ConnectReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.server().size() > 0) {

    server_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_);
  }
  if (from.cookie().size() > 0) {

    cookie_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cookie_);
  }
  if (from.token().size() > 0) {

    token_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.token_);
  }
}

void ConnectReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.ConnectReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectReq::CopyFrom(const ConnectReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.ConnectReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectReq::IsInitialized() const {

  return true;
}

void ConnectReq::Swap(ConnectReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConnectReq::InternalSwap(ConnectReq* other) {
  server_.Swap(&other->server_);
  cookie_.Swap(&other->cookie_);
  token_.Swap(&other->token_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConnectReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConnectReq_descriptor_;
  metadata.reflection = ConnectReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConnectReq

// optional string server = 1;
void ConnectReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ConnectReq::server() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.server)
}
 void ConnectReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.server)
}
 void ConnectReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.server)
}
 ::std::string* ConnectReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConnectReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.server)
}

// optional string cookie = 2;
void ConnectReq::clear_cookie() {
  cookie_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ConnectReq::cookie() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.cookie)
  return cookie_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_cookie(const ::std::string& value) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.cookie)
}
 void ConnectReq::set_cookie(const char* value) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.cookie)
}
 void ConnectReq::set_cookie(const char* value, size_t size) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.cookie)
}
 ::std::string* ConnectReq::mutable_cookie() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.cookie)
  return cookie_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConnectReq::release_cookie() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.cookie)
  
  return cookie_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_allocated_cookie(::std::string* cookie) {
  if (cookie != NULL) {
    
  } else {
    
  }
  cookie_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cookie);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.cookie)
}

// optional bytes token = 3;
void ConnectReq::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ConnectReq::token() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.token)
}
 void ConnectReq::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.token)
}
 void ConnectReq::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.token)
}
 ::std::string* ConnectReq::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConnectReq::release_token() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReq::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.token)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ConnectReply::kMidFieldNumber;
const int ConnectReply::kKeyFieldNumber;
const int ConnectReply::kRoomIDFieldNumber;
const int ConnectReply::kAcceptsFieldNumber;
const int ConnectReply::kHeartbeatFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ConnectReply::ConnectReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.ConnectReply)
}

void ConnectReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ConnectReply::ConnectReply(const ConnectReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.ConnectReply)
}

void ConnectReply::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mid_ = GOOGLE_LONGLONG(0);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  heartbeat_ = GOOGLE_LONGLONG(0);
}

ConnectReply::~ConnectReply() {
  // @@protoc_insertion_point(destructor:logic.ConnectReply)
  SharedDtor();
}

void ConnectReply::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void ConnectReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConnectReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConnectReply_descriptor_;
}

const ConnectReply& ConnectReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

ConnectReply* ConnectReply::default_instance_ = NULL;

ConnectReply* ConnectReply::New(::google::protobuf::Arena* arena) const {
  ConnectReply* n = new ConnectReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ConnectReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.ConnectReply)
  mid_ = GOOGLE_LONGLONG(0);
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  heartbeat_ = GOOGLE_LONGLONG(0);
  accepts_.Clear();
}

bool ConnectReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.ConnectReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 mid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.ConnectReply.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_roomID;
        break;
      }

      // optional string roomID = 3;
      case 3: {
        if (tag == 26) {
         parse_roomID:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roomid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->roomid().data(), this->roomid().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.ConnectReply.roomID"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_accepts;
        break;
      }

      // repeated int32 accepts = 4;
      case 4: {
        if (tag == 34) {
         parse_accepts:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_accepts())));
        } else if (tag == 32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 34, input, this->mutable_accepts())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_heartbeat;
        break;
      }

      // optional int64 heartbeat = 5;
      case 5: {
        if (tag == 40) {
         parse_heartbeat:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &heartbeat_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.ConnectReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.ConnectReply)
  return false;
#undef DO_
}

void ConnectReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.ConnectReply)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->mid(), output);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReply.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional string roomID = 3;
  if (this->roomid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->roomid().data(), this->roomid().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReply.roomID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->roomid(), output);
  }

  // repeated int32 accepts = 4;
  if (this->accepts_size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteTag(4, ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED, output);
    output->WriteVarint32(_accepts_cached_byte_size_);
  }
  for (int i = 0; i < this->accepts_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32NoTag(
      this->accepts(i), output);
  }

  // optional int64 heartbeat = 5;
  if (this->heartbeat() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->heartbeat(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.ConnectReply)
}

::google::protobuf::uint8* ConnectReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.ConnectReply)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->mid(), target);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReply.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  // optional string roomID = 3;
  if (this->roomid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->roomid().data(), this->roomid().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.ConnectReply.roomID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->roomid(), target);
  }

  // repeated int32 accepts = 4;
  if (this->accepts_size() > 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteTagToArray(
      4,
      ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED,
      target);
    target = ::google::protobuf::io::CodedOutputStream::WriteVarint32ToArray(
      _accepts_cached_byte_size_, target);
  }
  for (int i = 0; i < this->accepts_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32NoTagToArray(this->accepts(i), target);
  }

  // optional int64 heartbeat = 5;
  if (this->heartbeat() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->heartbeat(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.ConnectReply)
  return target;
}

int ConnectReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.ConnectReply)
  int total_size = 0;

  // optional int64 mid = 1;
  if (this->mid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->mid());
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  // optional string roomID = 3;
  if (this->roomid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->roomid());
  }

  // optional int64 heartbeat = 5;
  if (this->heartbeat() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->heartbeat());
  }

  // repeated int32 accepts = 4;
  {
    int data_size = 0;
    for (int i = 0; i < this->accepts_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->accepts(i));
    }
    if (data_size > 0) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(data_size);
    }
    GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
    _accepts_cached_byte_size_ = data_size;
    GOOGLE_SAFE_CONCURRENT_WRITES_END();
    total_size += data_size;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConnectReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.ConnectReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ConnectReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ConnectReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.ConnectReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.ConnectReply)
    MergeFrom(*source);
  }
}

void ConnectReply::MergeFrom(const ConnectReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.ConnectReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  accepts_.MergeFrom(from.accepts_);
  if (from.mid() != 0) {
    set_mid(from.mid());
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.roomid().size() > 0) {

    roomid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.roomid_);
  }
  if (from.heartbeat() != 0) {
    set_heartbeat(from.heartbeat());
  }
}

void ConnectReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.ConnectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConnectReply::CopyFrom(const ConnectReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.ConnectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConnectReply::IsInitialized() const {

  return true;
}

void ConnectReply::Swap(ConnectReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ConnectReply::InternalSwap(ConnectReply* other) {
  std::swap(mid_, other->mid_);
  key_.Swap(&other->key_);
  roomid_.Swap(&other->roomid_);
  accepts_.UnsafeArenaSwap(&other->accepts_);
  std::swap(heartbeat_, other->heartbeat_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ConnectReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConnectReply_descriptor_;
  metadata.reflection = ConnectReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ConnectReply

// optional int64 mid = 1;
void ConnectReply::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 ConnectReply::mid() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.mid)
  return mid_;
}
 void ConnectReply::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.ConnectReply.mid)
}

// optional string key = 2;
void ConnectReply::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ConnectReply::key() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReply::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.key)
}
 void ConnectReply::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReply.key)
}
 void ConnectReply::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReply.key)
}
 ::std::string* ConnectReply::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReply.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConnectReply::release_key() {
  // @@protoc_insertion_point(field_release:logic.ConnectReply.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReply::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReply.key)
}

// optional string roomID = 3;
void ConnectReply::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& ConnectReply::roomid() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.roomID)
  return roomid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReply::set_roomid(const ::std::string& value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.roomID)
}
 void ConnectReply::set_roomid(const char* value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReply.roomID)
}
 void ConnectReply::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReply.roomID)
}
 ::std::string* ConnectReply::mutable_roomid() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReply.roomID)
  return roomid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* ConnectReply::release_roomid() {
  // @@protoc_insertion_point(field_release:logic.ConnectReply.roomID)
  
  return roomid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void ConnectReply::set_allocated_roomid(::std::string* roomid) {
  if (roomid != NULL) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReply.roomID)
}

// repeated int32 accepts = 4;
int ConnectReply::accepts_size() const {
  return accepts_.size();
}
void ConnectReply::clear_accepts() {
  accepts_.Clear();
}
 ::google::protobuf::int32 ConnectReply::accepts(int index) const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.accepts)
  return accepts_.Get(index);
}
 void ConnectReply::set_accepts(int index, ::google::protobuf::int32 value) {
  accepts_.Set(index, value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.accepts)
}
 void ConnectReply::add_accepts(::google::protobuf::int32 value) {
  accepts_.Add(value);
  // @@protoc_insertion_point(field_add:logic.ConnectReply.accepts)
}
 const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConnectReply::accepts() const {
  // @@protoc_insertion_point(field_list:logic.ConnectReply.accepts)
  return accepts_;
}
 ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConnectReply::mutable_accepts() {
  // @@protoc_insertion_point(field_mutable_list:logic.ConnectReply.accepts)
  return &accepts_;
}

// optional int64 heartbeat = 5;
void ConnectReply::clear_heartbeat() {
  heartbeat_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 ConnectReply::heartbeat() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.heartbeat)
  return heartbeat_;
}
 void ConnectReply::set_heartbeat(::google::protobuf::int64 value) {
  
  heartbeat_ = value;
  // @@protoc_insertion_point(field_set:logic.ConnectReply.heartbeat)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DisconnectReq::kMidFieldNumber;
const int DisconnectReq::kKeyFieldNumber;
const int DisconnectReq::kServerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DisconnectReq::DisconnectReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.DisconnectReq)
}

void DisconnectReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

DisconnectReq::DisconnectReq(const DisconnectReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.DisconnectReq)
}

void DisconnectReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mid_ = GOOGLE_LONGLONG(0);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

DisconnectReq::~DisconnectReq() {
  // @@protoc_insertion_point(destructor:logic.DisconnectReq)
  SharedDtor();
}

void DisconnectReq::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void DisconnectReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisconnectReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisconnectReq_descriptor_;
}

const DisconnectReq& DisconnectReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

DisconnectReq* DisconnectReq::default_instance_ = NULL;

DisconnectReq* DisconnectReq::New(::google::protobuf::Arena* arena) const {
  DisconnectReq* n = new DisconnectReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DisconnectReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.DisconnectReq)
  mid_ = GOOGLE_LONGLONG(0);
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool DisconnectReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.DisconnectReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 mid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.DisconnectReq.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_server;
        break;
      }

      // optional string server = 3;
      case 3: {
        if (tag == 26) {
         parse_server:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.DisconnectReq.server"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.DisconnectReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.DisconnectReq)
  return false;
#undef DO_
}

void DisconnectReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.DisconnectReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->mid(), output);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.DisconnectReq.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.DisconnectReq.server");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->server(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.DisconnectReq)
}

::google::protobuf::uint8* DisconnectReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.DisconnectReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->mid(), target);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.DisconnectReq.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.DisconnectReq.server");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->server(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.DisconnectReq)
  return target;
}

int DisconnectReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.DisconnectReq)
  int total_size = 0;

  // optional int64 mid = 1;
  if (this->mid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->mid());
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->server());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisconnectReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.DisconnectReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DisconnectReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DisconnectReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.DisconnectReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.DisconnectReq)
    MergeFrom(*source);
  }
}

void DisconnectReq::MergeFrom(const DisconnectReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.DisconnectReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.mid() != 0) {
    set_mid(from.mid());
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.server().size() > 0) {

    server_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_);
  }
}

void DisconnectReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.DisconnectReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisconnectReq::CopyFrom(const DisconnectReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.DisconnectReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisconnectReq::IsInitialized() const {

  return true;
}

void DisconnectReq::Swap(DisconnectReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DisconnectReq::InternalSwap(DisconnectReq* other) {
  std::swap(mid_, other->mid_);
  key_.Swap(&other->key_);
  server_.Swap(&other->server_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DisconnectReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisconnectReq_descriptor_;
  metadata.reflection = DisconnectReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DisconnectReq

// optional int64 mid = 1;
void DisconnectReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 DisconnectReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.mid)
  return mid_;
}
 void DisconnectReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.mid)
}

// optional string key = 2;
void DisconnectReq::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DisconnectReq::key() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DisconnectReq::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.key)
}
 void DisconnectReq::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.DisconnectReq.key)
}
 void DisconnectReq::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.DisconnectReq.key)
}
 ::std::string* DisconnectReq::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.DisconnectReq.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DisconnectReq::release_key() {
  // @@protoc_insertion_point(field_release:logic.DisconnectReq.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DisconnectReq::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.DisconnectReq.key)
}

// optional string server = 3;
void DisconnectReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& DisconnectReq::server() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DisconnectReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.server)
}
 void DisconnectReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.DisconnectReq.server)
}
 void DisconnectReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.DisconnectReq.server)
}
 ::std::string* DisconnectReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.DisconnectReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* DisconnectReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.DisconnectReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void DisconnectReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.DisconnectReq.server)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int DisconnectReply::kHasFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

DisconnectReply::DisconnectReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.DisconnectReply)
}

void DisconnectReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

DisconnectReply::DisconnectReply(const DisconnectReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.DisconnectReply)
}

void DisconnectReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  has_ = false;
}

DisconnectReply::~DisconnectReply() {
  // @@protoc_insertion_point(destructor:logic.DisconnectReply)
  SharedDtor();
}

void DisconnectReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void DisconnectReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DisconnectReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DisconnectReply_descriptor_;
}

const DisconnectReply& DisconnectReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

DisconnectReply* DisconnectReply::default_instance_ = NULL;

DisconnectReply* DisconnectReply::New(::google::protobuf::Arena* arena) const {
  DisconnectReply* n = new DisconnectReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void DisconnectReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.DisconnectReply)
  has_ = false;
}

bool DisconnectReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.DisconnectReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool has = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &has_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.DisconnectReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.DisconnectReply)
  return false;
#undef DO_
}

void DisconnectReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.DisconnectReply)
  // optional bool has = 1;
  if (this->has() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->has(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.DisconnectReply)
}

::google::protobuf::uint8* DisconnectReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.DisconnectReply)
  // optional bool has = 1;
  if (this->has() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->has(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.DisconnectReply)
  return target;
}

int DisconnectReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.DisconnectReply)
  int total_size = 0;

  // optional bool has = 1;
  if (this->has() != 0) {
    total_size += 1 + 1;
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DisconnectReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.DisconnectReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const DisconnectReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const DisconnectReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.DisconnectReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.DisconnectReply)
    MergeFrom(*source);
  }
}

void DisconnectReply::MergeFrom(const DisconnectReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.DisconnectReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.has() != 0) {
    set_has(from.has());
  }
}

void DisconnectReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.DisconnectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DisconnectReply::CopyFrom(const DisconnectReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.DisconnectReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DisconnectReply::IsInitialized() const {

  return true;
}

void DisconnectReply::Swap(DisconnectReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void DisconnectReply::InternalSwap(DisconnectReply* other) {
  std::swap(has_, other->has_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata DisconnectReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DisconnectReply_descriptor_;
  metadata.reflection = DisconnectReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// DisconnectReply

// optional bool has = 1;
void DisconnectReply::clear_has() {
  has_ = false;
}
 bool DisconnectReply::has() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReply.has)
  return has_;
}
 void DisconnectReply::set_has(bool value) {
  
  has_ = value;
  // @@protoc_insertion_point(field_set:logic.DisconnectReply.has)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int HeartbeatReq::kMidFieldNumber;
const int HeartbeatReq::kKeyFieldNumber;
const int HeartbeatReq::kServerFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatReq::HeartbeatReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.HeartbeatReq)
}

void HeartbeatReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

HeartbeatReq::HeartbeatReq(const HeartbeatReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.HeartbeatReq)
}

void HeartbeatReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  mid_ = GOOGLE_LONGLONG(0);
  key_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

HeartbeatReq::~HeartbeatReq() {
  // @@protoc_insertion_point(destructor:logic.HeartbeatReq)
  SharedDtor();
}

void HeartbeatReq::SharedDtor() {
  key_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void HeartbeatReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatReq_descriptor_;
}

const HeartbeatReq& HeartbeatReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

HeartbeatReq* HeartbeatReq::default_instance_ = NULL;

HeartbeatReq* HeartbeatReq::New(::google::protobuf::Arena* arena) const {
  HeartbeatReq* n = new HeartbeatReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.HeartbeatReq)
  mid_ = GOOGLE_LONGLONG(0);
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool HeartbeatReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.HeartbeatReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 mid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_key;
        break;
      }

      // optional string key = 2;
      case 2: {
        if (tag == 18) {
         parse_key:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.HeartbeatReq.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_server;
        break;
      }

      // optional string server = 3;
      case 3: {
        if (tag == 26) {
         parse_server:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.HeartbeatReq.server"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.HeartbeatReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.HeartbeatReq)
  return false;
#undef DO_
}

void HeartbeatReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.HeartbeatReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->mid(), output);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.HeartbeatReq.key");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->key(), output);
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.HeartbeatReq.server");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->server(), output);
  }

  // @@protoc_insertion_point(serialize_end:logic.HeartbeatReq)
}

::google::protobuf::uint8* HeartbeatReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.HeartbeatReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->mid(), target);
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.HeartbeatReq.key");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->key(), target);
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.HeartbeatReq.server");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->server(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.HeartbeatReq)
  return target;
}

int HeartbeatReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.HeartbeatReq)
  int total_size = 0;

  // optional int64 mid = 1;
  if (this->mid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->mid());
  }

  // optional string key = 2;
  if (this->key().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->key());
  }

  // optional string server = 3;
  if (this->server().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->server());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.HeartbeatReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HeartbeatReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.HeartbeatReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.HeartbeatReq)
    MergeFrom(*source);
  }
}

void HeartbeatReq::MergeFrom(const HeartbeatReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.HeartbeatReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.mid() != 0) {
    set_mid(from.mid());
  }
  if (from.key().size() > 0) {

    key_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.key_);
  }
  if (from.server().size() > 0) {

    server_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_);
  }
}

void HeartbeatReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.HeartbeatReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatReq::CopyFrom(const HeartbeatReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.HeartbeatReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatReq::IsInitialized() const {

  return true;
}

void HeartbeatReq::Swap(HeartbeatReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatReq::InternalSwap(HeartbeatReq* other) {
  std::swap(mid_, other->mid_);
  key_.Swap(&other->key_);
  server_.Swap(&other->server_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatReq_descriptor_;
  metadata.reflection = HeartbeatReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatReq

// optional int64 mid = 1;
void HeartbeatReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 HeartbeatReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.mid)
  return mid_;
}
 void HeartbeatReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.mid)
}

// optional string key = 2;
void HeartbeatReq::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& HeartbeatReq::key() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeartbeatReq::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.key)
}
 void HeartbeatReq::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.HeartbeatReq.key)
}
 void HeartbeatReq::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.HeartbeatReq.key)
}
 ::std::string* HeartbeatReq::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.HeartbeatReq.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HeartbeatReq::release_key() {
  // @@protoc_insertion_point(field_release:logic.HeartbeatReq.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeartbeatReq::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.HeartbeatReq.key)
}

// optional string server = 3;
void HeartbeatReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& HeartbeatReq::server() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeartbeatReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.server)
}
 void HeartbeatReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.HeartbeatReq.server)
}
 void HeartbeatReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.HeartbeatReq.server)
}
 ::std::string* HeartbeatReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.HeartbeatReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* HeartbeatReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.HeartbeatReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void HeartbeatReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.HeartbeatReq.server)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

HeartbeatReply::HeartbeatReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.HeartbeatReply)
}

void HeartbeatReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

HeartbeatReply::HeartbeatReply(const HeartbeatReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.HeartbeatReply)
}

void HeartbeatReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

HeartbeatReply::~HeartbeatReply() {
  // @@protoc_insertion_point(destructor:logic.HeartbeatReply)
  SharedDtor();
}

void HeartbeatReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HeartbeatReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HeartbeatReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HeartbeatReply_descriptor_;
}

const HeartbeatReply& HeartbeatReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

HeartbeatReply* HeartbeatReply::default_instance_ = NULL;

HeartbeatReply* HeartbeatReply::New(::google::protobuf::Arena* arena) const {
  HeartbeatReply* n = new HeartbeatReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void HeartbeatReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.HeartbeatReply)
}

bool HeartbeatReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.HeartbeatReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.HeartbeatReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.HeartbeatReply)
  return false;
#undef DO_
}

void HeartbeatReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.HeartbeatReply)
  // @@protoc_insertion_point(serialize_end:logic.HeartbeatReply)
}

::google::protobuf::uint8* HeartbeatReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.HeartbeatReply)
  // @@protoc_insertion_point(serialize_to_array_end:logic.HeartbeatReply)
  return target;
}

int HeartbeatReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.HeartbeatReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HeartbeatReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.HeartbeatReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const HeartbeatReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const HeartbeatReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.HeartbeatReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.HeartbeatReply)
    MergeFrom(*source);
  }
}

void HeartbeatReply::MergeFrom(const HeartbeatReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.HeartbeatReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void HeartbeatReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.HeartbeatReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HeartbeatReply::CopyFrom(const HeartbeatReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.HeartbeatReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HeartbeatReply::IsInitialized() const {

  return true;
}

void HeartbeatReply::Swap(HeartbeatReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void HeartbeatReply::InternalSwap(HeartbeatReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata HeartbeatReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HeartbeatReply_descriptor_;
  metadata.reflection = HeartbeatReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// HeartbeatReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OnlineReq::kServerFieldNumber;
const int OnlineReq::kRoomCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OnlineReq::OnlineReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.OnlineReq)
}

void OnlineReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

OnlineReq::OnlineReq(const OnlineReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.OnlineReq)
}

void OnlineReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  server_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomcount_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  roomcount_.SetEntryDescriptor(
      &::logic::OnlineReq_RoomCountEntry_descriptor_);
}

OnlineReq::~OnlineReq() {
  // @@protoc_insertion_point(destructor:logic.OnlineReq)
  SharedDtor();
}

void OnlineReq::SharedDtor() {
  server_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void OnlineReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OnlineReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OnlineReq_descriptor_;
}

const OnlineReq& OnlineReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

OnlineReq* OnlineReq::default_instance_ = NULL;

OnlineReq* OnlineReq::New(::google::protobuf::Arena* arena) const {
  OnlineReq* n = new OnlineReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OnlineReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.OnlineReq)
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  roomcount_.Clear();
}

bool OnlineReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.OnlineReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string server = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->server().data(), this->server().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.OnlineReq.server"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_roomCount;
        break;
      }

      // map<string, int32> roomCount = 2;
      case 2: {
        if (tag == 18) {
         parse_roomCount:
          DO_(input->IncrementRecursionDepth());
         parse_loop_roomCount:
          OnlineReq_RoomCountEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::google::protobuf::int32,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
              0 >,
            ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 > > parser(&roomcount_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.OnlineReq.RoomCountEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_loop_roomCount;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.OnlineReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.OnlineReq)
  return false;
#undef DO_
}

void OnlineReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.OnlineReq)
  // optional string server = 1;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.OnlineReq.server");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->server(), output);
  }

  // map<string, int32> roomCount = 2;
  if (!this->roomcount().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "logic.OnlineReq.RoomCountEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->roomcount().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->roomcount().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->roomcount().begin();
          it != this->roomcount().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<OnlineReq_RoomCountEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(roomcount_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            2, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<OnlineReq_RoomCountEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->roomcount().begin();
          it != this->roomcount().end(); ++it) {
        entry.reset(roomcount_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            2, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:logic.OnlineReq)
}

::google::protobuf::uint8* OnlineReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.OnlineReq)
  // optional string server = 1;
  if (this->server().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->server().data(), this->server().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "logic.OnlineReq.server");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->server(), target);
  }

  // map<string, int32> roomCount = 2;
  if (!this->roomcount().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "logic.OnlineReq.RoomCountEntry.key");
      }
    };

    if (deterministic &&
        this->roomcount().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->roomcount().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->roomcount().begin();
          it != this->roomcount().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<OnlineReq_RoomCountEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(roomcount_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       2, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<OnlineReq_RoomCountEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->roomcount().begin();
          it != this->roomcount().end(); ++it) {
        entry.reset(roomcount_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       2, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.OnlineReq)
  return target;
}

int OnlineReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.OnlineReq)
  int total_size = 0;

  // optional string server = 1;
  if (this->server().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->server());
  }

  // map<string, int32> roomCount = 2;
  total_size += 1 * this->roomcount_size();
  {
    ::google::protobuf::scoped_ptr<OnlineReq_RoomCountEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
        it = this->roomcount().begin();
        it != this->roomcount().end(); ++it) {
      entry.reset(roomcount_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OnlineReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.OnlineReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OnlineReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OnlineReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.OnlineReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.OnlineReq)
    MergeFrom(*source);
  }
}

void OnlineReq::MergeFrom(const OnlineReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.OnlineReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  roomcount_.MergeFrom(from.roomcount_);
  if (from.server().size() > 0) {

    server_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.server_);
  }
}

void OnlineReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.OnlineReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OnlineReq::CopyFrom(const OnlineReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.OnlineReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnlineReq::IsInitialized() const {

  return true;
}

void OnlineReq::Swap(OnlineReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OnlineReq::InternalSwap(OnlineReq* other) {
  server_.Swap(&other->server_);
  roomcount_.Swap(&other->roomcount_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OnlineReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OnlineReq_descriptor_;
  metadata.reflection = OnlineReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OnlineReq

// optional string server = 1;
void OnlineReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& OnlineReq::server() const {
  // @@protoc_insertion_point(field_get:logic.OnlineReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OnlineReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.OnlineReq.server)
}
 void OnlineReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.OnlineReq.server)
}
 void OnlineReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.OnlineReq.server)
}
 ::std::string* OnlineReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.OnlineReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* OnlineReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.OnlineReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void OnlineReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.OnlineReq.server)
}

// map<string, int32> roomCount = 2;
int OnlineReq::roomcount_size() const {
  return roomcount_.size();
}
void OnlineReq::clear_roomcount() {
  roomcount_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
OnlineReq::roomcount() const {
  // @@protoc_insertion_point(field_map:logic.OnlineReq.roomCount)
  return roomcount_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
OnlineReq::mutable_roomcount() {
  // @@protoc_insertion_point(field_mutable_map:logic.OnlineReq.roomCount)
  return roomcount_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int OnlineReply::kAllRoomCountFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

OnlineReply::OnlineReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.OnlineReply)
}

void OnlineReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

OnlineReply::OnlineReply(const OnlineReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.OnlineReply)
}

void OnlineReply::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  allroomcount_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  allroomcount_.SetEntryDescriptor(
      &::logic::OnlineReply_AllRoomCountEntry_descriptor_);
}

OnlineReply::~OnlineReply() {
  // @@protoc_insertion_point(destructor:logic.OnlineReply)
  SharedDtor();
}

void OnlineReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OnlineReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OnlineReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OnlineReply_descriptor_;
}

const OnlineReply& OnlineReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

OnlineReply* OnlineReply::default_instance_ = NULL;

OnlineReply* OnlineReply::New(::google::protobuf::Arena* arena) const {
  OnlineReply* n = new OnlineReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void OnlineReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.OnlineReply)
  allroomcount_.Clear();
}

bool OnlineReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.OnlineReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, int32> allRoomCount = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_allRoomCount:
          OnlineReply_AllRoomCountEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, ::google::protobuf::int32,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
              0 >,
            ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 > > parser(&allroomcount_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "logic.OnlineReply.AllRoomCountEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_allRoomCount;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.OnlineReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.OnlineReply)
  return false;
#undef DO_
}

void OnlineReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.OnlineReply)
  // map<string, int32> allRoomCount = 1;
  if (!this->allroomcount().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "logic.OnlineReply.AllRoomCountEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->allroomcount().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->allroomcount().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->allroomcount().begin();
          it != this->allroomcount().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<OnlineReply_AllRoomCountEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(allroomcount_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<OnlineReply_AllRoomCountEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->allroomcount().begin();
          it != this->allroomcount().end(); ++it) {
        entry.reset(allroomcount_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:logic.OnlineReply)
}

::google::protobuf::uint8* OnlineReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.OnlineReply)
  // map<string, int32> allRoomCount = 1;
  if (!this->allroomcount().empty()) {
    typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "logic.OnlineReply.AllRoomCountEntry.key");
      }
    };

    if (deterministic &&
        this->allroomcount().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->allroomcount().size()]);
      typedef ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->allroomcount().begin();
          it != this->allroomcount().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<OnlineReply_AllRoomCountEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(allroomcount_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<OnlineReply_AllRoomCountEntry> entry;
      for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
          it = this->allroomcount().begin();
          it != this->allroomcount().end(); ++it) {
        entry.reset(allroomcount_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.OnlineReply)
  return target;
}

int OnlineReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.OnlineReply)
  int total_size = 0;

  // map<string, int32> allRoomCount = 1;
  total_size += 1 * this->allroomcount_size();
  {
    ::google::protobuf::scoped_ptr<OnlineReply_AllRoomCountEntry> entry;
    for (::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >::const_iterator
        it = this->allroomcount().begin();
        it != this->allroomcount().end(); ++it) {
      entry.reset(allroomcount_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OnlineReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.OnlineReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const OnlineReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const OnlineReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.OnlineReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.OnlineReply)
    MergeFrom(*source);
  }
}

void OnlineReply::MergeFrom(const OnlineReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.OnlineReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  allroomcount_.MergeFrom(from.allroomcount_);
}

void OnlineReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.OnlineReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OnlineReply::CopyFrom(const OnlineReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.OnlineReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OnlineReply::IsInitialized() const {

  return true;
}

void OnlineReply::Swap(OnlineReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void OnlineReply::InternalSwap(OnlineReply* other) {
  allroomcount_.Swap(&other->allroomcount_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata OnlineReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OnlineReply_descriptor_;
  metadata.reflection = OnlineReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// OnlineReply

// map<string, int32> allRoomCount = 1;
int OnlineReply::allroomcount_size() const {
  return allroomcount_.size();
}
void OnlineReply::clear_allroomcount() {
  allroomcount_.Clear();
}
 const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
OnlineReply::allroomcount() const {
  // @@protoc_insertion_point(field_map:logic.OnlineReply.allRoomCount)
  return allroomcount_.GetMap();
}
 ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
OnlineReply::mutable_allroomcount() {
  // @@protoc_insertion_point(field_mutable_map:logic.OnlineReply.allRoomCount)
  return allroomcount_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int ReceiveReq::kMidFieldNumber;
const int ReceiveReq::kProtoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReceiveReq::ReceiveReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.ReceiveReq)
}

void ReceiveReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  proto_ = const_cast< ::gate::Proto*>(&::gate::Proto::default_instance());
}

ReceiveReq::ReceiveReq(const ReceiveReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.ReceiveReq)
}

void ReceiveReq::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  mid_ = GOOGLE_LONGLONG(0);
  proto_ = NULL;
}

ReceiveReq::~ReceiveReq() {
  // @@protoc_insertion_point(destructor:logic.ReceiveReq)
  SharedDtor();
}

void ReceiveReq::SharedDtor() {
  if (this != default_instance_) {
    delete proto_;
  }
}

void ReceiveReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReceiveReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReceiveReq_descriptor_;
}

const ReceiveReq& ReceiveReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

ReceiveReq* ReceiveReq::default_instance_ = NULL;

ReceiveReq* ReceiveReq::New(::google::protobuf::Arena* arena) const {
  ReceiveReq* n = new ReceiveReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReceiveReq::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.ReceiveReq)
  mid_ = GOOGLE_LONGLONG(0);
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}

bool ReceiveReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.ReceiveReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int64 mid = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &mid_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_proto;
        break;
      }

      // optional .gate.Proto proto = 2;
      case 2: {
        if (tag == 18) {
         parse_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:logic.ReceiveReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.ReceiveReq)
  return false;
#undef DO_
}

void ReceiveReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.ReceiveReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->mid(), output);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->proto_, output);
  }

  // @@protoc_insertion_point(serialize_end:logic.ReceiveReq)
}

::google::protobuf::uint8* ReceiveReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.ReceiveReq)
  // optional int64 mid = 1;
  if (this->mid() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->mid(), target);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->proto_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:logic.ReceiveReq)
  return target;
}

int ReceiveReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.ReceiveReq)
  int total_size = 0;

  // optional int64 mid = 1;
  if (this->mid() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int64Size(
        this->mid());
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->proto_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReceiveReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.ReceiveReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReceiveReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReceiveReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.ReceiveReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.ReceiveReq)
    MergeFrom(*source);
  }
}

void ReceiveReq::MergeFrom(const ReceiveReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.ReceiveReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.mid() != 0) {
    set_mid(from.mid());
  }
  if (from.has_proto()) {
    mutable_proto()->::gate::Proto::MergeFrom(from.proto());
  }
}

void ReceiveReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.ReceiveReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReceiveReq::CopyFrom(const ReceiveReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.ReceiveReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveReq::IsInitialized() const {

  return true;
}

void ReceiveReq::Swap(ReceiveReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReceiveReq::InternalSwap(ReceiveReq* other) {
  std::swap(mid_, other->mid_);
  std::swap(proto_, other->proto_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReceiveReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReceiveReq_descriptor_;
  metadata.reflection = ReceiveReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReceiveReq

// optional int64 mid = 1;
void ReceiveReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
 ::google::protobuf::int64 ReceiveReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.ReceiveReq.mid)
  return mid_;
}
 void ReceiveReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.ReceiveReq.mid)
}

// optional .gate.Proto proto = 2;
bool ReceiveReq::has_proto() const {
  return !_is_default_instance_ && proto_ != NULL;
}
void ReceiveReq::clear_proto() {
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}
const ::gate::Proto& ReceiveReq::proto() const {
  // @@protoc_insertion_point(field_get:logic.ReceiveReq.proto)
  return proto_ != NULL ? *proto_ : *default_instance_->proto_;
}
::gate::Proto* ReceiveReq::mutable_proto() {
  
  if (proto_ == NULL) {
    proto_ = new ::gate::Proto;
  }
  // @@protoc_insertion_point(field_mutable:logic.ReceiveReq.proto)
  return proto_;
}
::gate::Proto* ReceiveReq::release_proto() {
  // @@protoc_insertion_point(field_release:logic.ReceiveReq.proto)
  
  ::gate::Proto* temp = proto_;
  proto_ = NULL;
  return temp;
}
void ReceiveReq::set_allocated_proto(::gate::Proto* proto) {
  delete proto_;
  proto_ = proto;
  if (proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:logic.ReceiveReq.proto)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

ReceiveReply::ReceiveReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:logic.ReceiveReply)
}

void ReceiveReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

ReceiveReply::ReceiveReply(const ReceiveReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:logic.ReceiveReply)
}

void ReceiveReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

ReceiveReply::~ReceiveReply() {
  // @@protoc_insertion_point(destructor:logic.ReceiveReply)
  SharedDtor();
}

void ReceiveReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ReceiveReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ReceiveReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReceiveReply_descriptor_;
}

const ReceiveReply& ReceiveReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_logic_2eproto();
  return *default_instance_;
}

ReceiveReply* ReceiveReply::default_instance_ = NULL;

ReceiveReply* ReceiveReply::New(::google::protobuf::Arena* arena) const {
  ReceiveReply* n = new ReceiveReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void ReceiveReply::Clear() {
// @@protoc_insertion_point(message_clear_start:logic.ReceiveReply)
}

bool ReceiveReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:logic.ReceiveReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:logic.ReceiveReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:logic.ReceiveReply)
  return false;
#undef DO_
}

void ReceiveReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:logic.ReceiveReply)
  // @@protoc_insertion_point(serialize_end:logic.ReceiveReply)
}

::google::protobuf::uint8* ReceiveReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:logic.ReceiveReply)
  // @@protoc_insertion_point(serialize_to_array_end:logic.ReceiveReply)
  return target;
}

int ReceiveReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:logic.ReceiveReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ReceiveReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:logic.ReceiveReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const ReceiveReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const ReceiveReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:logic.ReceiveReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:logic.ReceiveReply)
    MergeFrom(*source);
  }
}

void ReceiveReply::MergeFrom(const ReceiveReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:logic.ReceiveReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void ReceiveReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:logic.ReceiveReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ReceiveReply::CopyFrom(const ReceiveReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:logic.ReceiveReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ReceiveReply::IsInitialized() const {

  return true;
}

void ReceiveReply::Swap(ReceiveReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void ReceiveReply::InternalSwap(ReceiveReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata ReceiveReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ReceiveReply_descriptor_;
  metadata.reflection = ReceiveReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// ReceiveReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

Logic::~Logic() {}

const ::google::protobuf::ServiceDescriptor* Logic::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Logic_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* Logic::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return Logic_descriptor_;
}

void Logic::Ping(::google::protobuf::RpcController* controller,
                         const ::logic::PingReq*,
                         ::logic::PingReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Ping() not implemented.");
  done->Run();
}

void Logic::Close(::google::protobuf::RpcController* controller,
                         const ::logic::CloseReq*,
                         ::logic::CloseReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Close() not implemented.");
  done->Run();
}

void Logic::Connect(::google::protobuf::RpcController* controller,
                         const ::logic::ConnectReq*,
                         ::logic::ConnectReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Connect() not implemented.");
  done->Run();
}

void Logic::Disconnect(::google::protobuf::RpcController* controller,
                         const ::logic::DisconnectReq*,
                         ::logic::DisconnectReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Disconnect() not implemented.");
  done->Run();
}

void Logic::Heartbeat(::google::protobuf::RpcController* controller,
                         const ::logic::HeartbeatReq*,
                         ::logic::HeartbeatReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Heartbeat() not implemented.");
  done->Run();
}

void Logic::RenewOnline(::google::protobuf::RpcController* controller,
                         const ::logic::OnlineReq*,
                         ::logic::OnlineReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method RenewOnline() not implemented.");
  done->Run();
}

void Logic::Receive(::google::protobuf::RpcController* controller,
                         const ::logic::ReceiveReq*,
                         ::logic::ReceiveReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Receive() not implemented.");
  done->Run();
}

void Logic::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), Logic_descriptor_);
  switch(method->index()) {
    case 0:
      Ping(controller,
             ::google::protobuf::down_cast<const ::logic::PingReq*>(request),
             ::google::protobuf::down_cast< ::logic::PingReply*>(response),
             done);
      break;
    case 1:
      Close(controller,
             ::google::protobuf::down_cast<const ::logic::CloseReq*>(request),
             ::google::protobuf::down_cast< ::logic::CloseReply*>(response),
             done);
      break;
    case 2:
      Connect(controller,
             ::google::protobuf::down_cast<const ::logic::ConnectReq*>(request),
             ::google::protobuf::down_cast< ::logic::ConnectReply*>(response),
             done);
      break;
    case 3:
      Disconnect(controller,
             ::google::protobuf::down_cast<const ::logic::DisconnectReq*>(request),
             ::google::protobuf::down_cast< ::logic::DisconnectReply*>(response),
             done);
      break;
    case 4:
      Heartbeat(controller,
             ::google::protobuf::down_cast<const ::logic::HeartbeatReq*>(request),
             ::google::protobuf::down_cast< ::logic::HeartbeatReply*>(response),
             done);
      break;
    case 5:
      RenewOnline(controller,
             ::google::protobuf::down_cast<const ::logic::OnlineReq*>(request),
             ::google::protobuf::down_cast< ::logic::OnlineReply*>(response),
             done);
      break;
    case 6:
      Receive(controller,
             ::google::protobuf::down_cast<const ::logic::ReceiveReq*>(request),
             ::google::protobuf::down_cast< ::logic::ReceiveReply*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& Logic::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::logic::PingReq::default_instance();
    case 1:
      return ::logic::CloseReq::default_instance();
    case 2:
      return ::logic::ConnectReq::default_instance();
    case 3:
      return ::logic::DisconnectReq::default_instance();
    case 4:
      return ::logic::HeartbeatReq::default_instance();
    case 5:
      return ::logic::OnlineReq::default_instance();
    case 6:
      return ::logic::ReceiveReq::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::google::protobuf::Message& Logic::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::logic::PingReply::default_instance();
    case 1:
      return ::logic::CloseReply::default_instance();
    case 2:
      return ::logic::ConnectReply::default_instance();
    case 3:
      return ::logic::DisconnectReply::default_instance();
    case 4:
      return ::logic::HeartbeatReply::default_instance();
    case 5:
      return ::logic::OnlineReply::default_instance();
    case 6:
      return ::logic::ReceiveReply::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

Logic_Stub::Logic_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
Logic_Stub::Logic_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
Logic_Stub::~Logic_Stub() {
  if (owns_channel_) delete channel_;
}

void Logic_Stub::Ping(::google::protobuf::RpcController* controller,
                              const ::logic::PingReq* request,
                              ::logic::PingReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void Logic_Stub::Close(::google::protobuf::RpcController* controller,
                              const ::logic::CloseReq* request,
                              ::logic::CloseReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void Logic_Stub::Connect(::google::protobuf::RpcController* controller,
                              const ::logic::ConnectReq* request,
                              ::logic::ConnectReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void Logic_Stub::Disconnect(::google::protobuf::RpcController* controller,
                              const ::logic::DisconnectReq* request,
                              ::logic::DisconnectReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void Logic_Stub::Heartbeat(::google::protobuf::RpcController* controller,
                              const ::logic::HeartbeatReq* request,
                              ::logic::HeartbeatReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void Logic_Stub::RenewOnline(::google::protobuf::RpcController* controller,
                              const ::logic::OnlineReq* request,
                              ::logic::OnlineReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}
void Logic_Stub::Receive(::google::protobuf::RpcController* controller,
                              const ::logic::ReceiveReq* request,
                              ::logic::ReceiveReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(6),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace logic

// @@protoc_insertion_point(global_scope)
