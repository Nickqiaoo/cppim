// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: gate.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "gate.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace gate {

namespace {

const ::google::protobuf::Descriptor* Proto_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Proto_reflection_ = NULL;
const ::google::protobuf::Descriptor* Empty_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Empty_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushMsgReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushMsgReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* PushMsgReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PushMsgReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* BroadcastReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BroadcastReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* BroadcastReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BroadcastReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* BroadcastRoomReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BroadcastRoomReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* BroadcastRoomReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  BroadcastRoomReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoomsReq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoomsReq_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoomsReply_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RoomsReply_reflection_ = NULL;
const ::google::protobuf::Descriptor* RoomsReply_RoomsEntry_descriptor_ = NULL;
const ::google::protobuf::ServiceDescriptor* Gate_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_gate_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_gate_2eproto() {
  protobuf_AddDesc_gate_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "gate.proto");
  GOOGLE_CHECK(file != NULL);
  Proto_descriptor_ = file->message_type(0);
  static const int Proto_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, ver_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, op_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, seq_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, body_),
  };
  Proto_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Proto_descriptor_,
      Proto::default_instance_,
      Proto_offsets_,
      -1,
      -1,
      -1,
      sizeof(Proto),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Proto, _is_default_instance_));
  Empty_descriptor_ = file->message_type(1);
  static const int Empty_offsets_[1] = {
  };
  Empty_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      Empty_descriptor_,
      Empty::default_instance_,
      Empty_offsets_,
      -1,
      -1,
      -1,
      sizeof(Empty),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Empty, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Empty, _is_default_instance_));
  PushMsgReq_descriptor_ = file->message_type(2);
  static const int PushMsgReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReq, keys_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReq, protoop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReq, proto_),
  };
  PushMsgReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushMsgReq_descriptor_,
      PushMsgReq::default_instance_,
      PushMsgReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(PushMsgReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReq, _is_default_instance_));
  PushMsgReply_descriptor_ = file->message_type(3);
  static const int PushMsgReply_offsets_[1] = {
  };
  PushMsgReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      PushMsgReply_descriptor_,
      PushMsgReply::default_instance_,
      PushMsgReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(PushMsgReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PushMsgReply, _is_default_instance_));
  BroadcastReq_descriptor_ = file->message_type(4);
  static const int BroadcastReq_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReq, protoop_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReq, proto_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReq, speed_),
  };
  BroadcastReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BroadcastReq_descriptor_,
      BroadcastReq::default_instance_,
      BroadcastReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(BroadcastReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReq, _is_default_instance_));
  BroadcastReply_descriptor_ = file->message_type(5);
  static const int BroadcastReply_offsets_[1] = {
  };
  BroadcastReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BroadcastReply_descriptor_,
      BroadcastReply::default_instance_,
      BroadcastReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(BroadcastReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastReply, _is_default_instance_));
  BroadcastRoomReq_descriptor_ = file->message_type(6);
  static const int BroadcastRoomReq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReq, roomid_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReq, proto_),
  };
  BroadcastRoomReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BroadcastRoomReq_descriptor_,
      BroadcastRoomReq::default_instance_,
      BroadcastRoomReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(BroadcastRoomReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReq, _is_default_instance_));
  BroadcastRoomReply_descriptor_ = file->message_type(7);
  static const int BroadcastRoomReply_offsets_[1] = {
  };
  BroadcastRoomReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      BroadcastRoomReply_descriptor_,
      BroadcastRoomReply::default_instance_,
      BroadcastRoomReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(BroadcastRoomReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(BroadcastRoomReply, _is_default_instance_));
  RoomsReq_descriptor_ = file->message_type(8);
  static const int RoomsReq_offsets_[1] = {
  };
  RoomsReq_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RoomsReq_descriptor_,
      RoomsReq::default_instance_,
      RoomsReq_offsets_,
      -1,
      -1,
      -1,
      sizeof(RoomsReq),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomsReq, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomsReq, _is_default_instance_));
  RoomsReply_descriptor_ = file->message_type(9);
  static const int RoomsReply_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomsReply, rooms_),
  };
  RoomsReply_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      RoomsReply_descriptor_,
      RoomsReply::default_instance_,
      RoomsReply_offsets_,
      -1,
      -1,
      -1,
      sizeof(RoomsReply),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomsReply, _internal_metadata_),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RoomsReply, _is_default_instance_));
  RoomsReply_RoomsEntry_descriptor_ = RoomsReply_descriptor_->nested_type(0);
  Gate_descriptor_ = file->service(0);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_gate_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Proto_descriptor_, &Proto::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      Empty_descriptor_, &Empty::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushMsgReq_descriptor_, &PushMsgReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      PushMsgReply_descriptor_, &PushMsgReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BroadcastReq_descriptor_, &BroadcastReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BroadcastReply_descriptor_, &BroadcastReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BroadcastRoomReq_descriptor_, &BroadcastRoomReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      BroadcastRoomReply_descriptor_, &BroadcastRoomReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RoomsReq_descriptor_, &RoomsReq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      RoomsReply_descriptor_, &RoomsReply::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
        RoomsReply_RoomsEntry_descriptor_,
        ::google::protobuf::internal::MapEntry<
            ::std::string,
            bool,
            ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
            ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
            0>::CreateDefaultInstance(
                RoomsReply_RoomsEntry_descriptor_));
}

}  // namespace

void protobuf_ShutdownFile_gate_2eproto() {
  delete Proto::default_instance_;
  delete Proto_reflection_;
  delete Empty::default_instance_;
  delete Empty_reflection_;
  delete PushMsgReq::default_instance_;
  delete PushMsgReq_reflection_;
  delete PushMsgReply::default_instance_;
  delete PushMsgReply_reflection_;
  delete BroadcastReq::default_instance_;
  delete BroadcastReq_reflection_;
  delete BroadcastReply::default_instance_;
  delete BroadcastReply_reflection_;
  delete BroadcastRoomReq::default_instance_;
  delete BroadcastRoomReq_reflection_;
  delete BroadcastRoomReply::default_instance_;
  delete BroadcastRoomReply_reflection_;
  delete RoomsReq::default_instance_;
  delete RoomsReq_reflection_;
  delete RoomsReply::default_instance_;
  delete RoomsReply_reflection_;
}

void protobuf_AddDesc_gate_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AddDesc_gate_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\ngate.proto\022\004gate\";\n\005Proto\022\013\n\003ver\030\001 \001(\005"
    "\022\n\n\002op\030\002 \001(\005\022\013\n\003seq\030\003 \001(\005\022\014\n\004body\030\004 \001(\014\""
    "\007\n\005Empty\"G\n\nPushMsgReq\022\014\n\004keys\030\001 \003(\t\022\017\n\007"
    "protoOp\030\003 \001(\005\022\032\n\005proto\030\002 \001(\0132\013.gate.Prot"
    "o\"\016\n\014PushMsgReply\"J\n\014BroadcastReq\022\017\n\007pro"
    "toOp\030\001 \001(\005\022\032\n\005proto\030\002 \001(\0132\013.gate.Proto\022\r"
    "\n\005speed\030\003 \001(\005\"\020\n\016BroadcastReply\">\n\020Broad"
    "castRoomReq\022\016\n\006roomID\030\001 \001(\t\022\032\n\005proto\030\002 \001"
    "(\0132\013.gate.Proto\"\024\n\022BroadcastRoomReply\"\n\n"
    "\010RoomsReq\"f\n\nRoomsReply\022*\n\005rooms\030\001 \003(\0132\033"
    ".gate.RoomsReply.RoomsEntry\032,\n\nRoomsEntr"
    "y\022\013\n\003key\030\001 \001(\t\022\r\n\005value\030\002 \001(\010:\0028\0012\241\002\n\004Ga"
    "te\022 \n\004Ping\022\013.gate.Empty\032\013.gate.Empty\022!\n\005"
    "Close\022\013.gate.Empty\032\013.gate.Empty\022/\n\007PushM"
    "sg\022\020.gate.PushMsgReq\032\022.gate.PushMsgReply"
    "\0225\n\tBroadcast\022\022.gate.BroadcastReq\032\024.gate"
    ".BroadcastReply\022A\n\rBroadcastRoom\022\026.gate."
    "BroadcastRoomReq\032\030.gate.BroadcastRoomRep"
    "ly\022)\n\005Rooms\022\016.gate.RoomsReq\032\020.gate.Rooms"
    "ReplyB\003\200\001\001b\006proto3", 778);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "gate.proto", &protobuf_RegisterTypes);
  Proto::default_instance_ = new Proto();
  Empty::default_instance_ = new Empty();
  PushMsgReq::default_instance_ = new PushMsgReq();
  PushMsgReply::default_instance_ = new PushMsgReply();
  BroadcastReq::default_instance_ = new BroadcastReq();
  BroadcastReply::default_instance_ = new BroadcastReply();
  BroadcastRoomReq::default_instance_ = new BroadcastRoomReq();
  BroadcastRoomReply::default_instance_ = new BroadcastRoomReply();
  RoomsReq::default_instance_ = new RoomsReq();
  RoomsReply::default_instance_ = new RoomsReply();
  Proto::default_instance_->InitAsDefaultInstance();
  Empty::default_instance_->InitAsDefaultInstance();
  PushMsgReq::default_instance_->InitAsDefaultInstance();
  PushMsgReply::default_instance_->InitAsDefaultInstance();
  BroadcastReq::default_instance_->InitAsDefaultInstance();
  BroadcastReply::default_instance_->InitAsDefaultInstance();
  BroadcastRoomReq::default_instance_->InitAsDefaultInstance();
  BroadcastRoomReply::default_instance_->InitAsDefaultInstance();
  RoomsReq::default_instance_->InitAsDefaultInstance();
  RoomsReply::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_gate_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_gate_2eproto {
  StaticDescriptorInitializer_gate_2eproto() {
    protobuf_AddDesc_gate_2eproto();
  }
} static_descriptor_initializer_gate_2eproto_;

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int Proto::kVerFieldNumber;
const int Proto::kOpFieldNumber;
const int Proto::kSeqFieldNumber;
const int Proto::kBodyFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Proto::Proto()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.Proto)
}

void Proto::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Proto::Proto(const Proto& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.Proto)
}

void Proto::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  ver_ = 0;
  op_ = 0;
  seq_ = 0;
  body_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

Proto::~Proto() {
  // @@protoc_insertion_point(destructor:gate.Proto)
  SharedDtor();
}

void Proto::SharedDtor() {
  body_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
  }
}

void Proto::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Proto::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Proto_descriptor_;
}

const Proto& Proto::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

Proto* Proto::default_instance_ = NULL;

Proto* Proto::New(::google::protobuf::Arena* arena) const {
  Proto* n = new Proto;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Proto::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.Proto)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(Proto, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<Proto*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(ver_, op_);
  seq_ = 0;
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());

#undef ZR_HELPER_
#undef ZR_

}

bool Proto::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.Proto)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 ver = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ver_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_op;
        break;
      }

      // optional int32 op = 2;
      case 2: {
        if (tag == 16) {
         parse_op:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &op_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_seq;
        break;
      }

      // optional int32 seq = 3;
      case 3: {
        if (tag == 24) {
         parse_seq:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &seq_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_body;
        break;
      }

      // optional bytes body = 4;
      case 4: {
        if (tag == 34) {
         parse_body:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_body()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gate.Proto)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.Proto)
  return false;
#undef DO_
}

void Proto::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.Proto)
  // optional int32 ver = 1;
  if (this->ver() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->ver(), output);
  }

  // optional int32 op = 2;
  if (this->op() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->op(), output);
  }

  // optional int32 seq = 3;
  if (this->seq() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->seq(), output);
  }

  // optional bytes body = 4;
  if (this->body().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      4, this->body(), output);
  }

  // @@protoc_insertion_point(serialize_end:gate.Proto)
}

::google::protobuf::uint8* Proto::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.Proto)
  // optional int32 ver = 1;
  if (this->ver() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->ver(), target);
  }

  // optional int32 op = 2;
  if (this->op() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->op(), target);
  }

  // optional int32 seq = 3;
  if (this->seq() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->seq(), target);
  }

  // optional bytes body = 4;
  if (this->body().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        4, this->body(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:gate.Proto)
  return target;
}

int Proto::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.Proto)
  int total_size = 0;

  // optional int32 ver = 1;
  if (this->ver() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->ver());
  }

  // optional int32 op = 2;
  if (this->op() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->op());
  }

  // optional int32 seq = 3;
  if (this->seq() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->seq());
  }

  // optional bytes body = 4;
  if (this->body().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->body());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Proto::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.Proto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Proto* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Proto>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.Proto)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.Proto)
    MergeFrom(*source);
  }
}

void Proto::MergeFrom(const Proto& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.Proto)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.ver() != 0) {
    set_ver(from.ver());
  }
  if (from.op() != 0) {
    set_op(from.op());
  }
  if (from.seq() != 0) {
    set_seq(from.seq());
  }
  if (from.body().size() > 0) {

    body_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.body_);
  }
}

void Proto::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.Proto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Proto::CopyFrom(const Proto& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.Proto)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Proto::IsInitialized() const {

  return true;
}

void Proto::Swap(Proto* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Proto::InternalSwap(Proto* other) {
  std::swap(ver_, other->ver_);
  std::swap(op_, other->op_);
  std::swap(seq_, other->seq_);
  body_.Swap(&other->body_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Proto::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Proto_descriptor_;
  metadata.reflection = Proto_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Proto

// optional int32 ver = 1;
void Proto::clear_ver() {
  ver_ = 0;
}
 ::google::protobuf::int32 Proto::ver() const {
  // @@protoc_insertion_point(field_get:gate.Proto.ver)
  return ver_;
}
 void Proto::set_ver(::google::protobuf::int32 value) {
  
  ver_ = value;
  // @@protoc_insertion_point(field_set:gate.Proto.ver)
}

// optional int32 op = 2;
void Proto::clear_op() {
  op_ = 0;
}
 ::google::protobuf::int32 Proto::op() const {
  // @@protoc_insertion_point(field_get:gate.Proto.op)
  return op_;
}
 void Proto::set_op(::google::protobuf::int32 value) {
  
  op_ = value;
  // @@protoc_insertion_point(field_set:gate.Proto.op)
}

// optional int32 seq = 3;
void Proto::clear_seq() {
  seq_ = 0;
}
 ::google::protobuf::int32 Proto::seq() const {
  // @@protoc_insertion_point(field_get:gate.Proto.seq)
  return seq_;
}
 void Proto::set_seq(::google::protobuf::int32 value) {
  
  seq_ = value;
  // @@protoc_insertion_point(field_set:gate.Proto.seq)
}

// optional bytes body = 4;
void Proto::clear_body() {
  body_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& Proto::body() const {
  // @@protoc_insertion_point(field_get:gate.Proto.body)
  return body_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Proto::set_body(const ::std::string& value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gate.Proto.body)
}
 void Proto::set_body(const char* value) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gate.Proto.body)
}
 void Proto::set_body(const void* value, size_t size) {
  
  body_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gate.Proto.body)
}
 ::std::string* Proto::mutable_body() {
  
  // @@protoc_insertion_point(field_mutable:gate.Proto.body)
  return body_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* Proto::release_body() {
  // @@protoc_insertion_point(field_release:gate.Proto.body)
  
  return body_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void Proto::set_allocated_body(::std::string* body) {
  if (body != NULL) {
    
  } else {
    
  }
  body_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), body);
  // @@protoc_insertion_point(field_set_allocated:gate.Proto.body)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

Empty::Empty()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.Empty)
}

void Empty::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

Empty::Empty(const Empty& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.Empty)
}

void Empty::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

Empty::~Empty() {
  // @@protoc_insertion_point(destructor:gate.Empty)
  SharedDtor();
}

void Empty::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Empty::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Empty::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Empty_descriptor_;
}

const Empty& Empty::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

Empty* Empty::default_instance_ = NULL;

Empty* Empty::New(::google::protobuf::Arena* arena) const {
  Empty* n = new Empty;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void Empty::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.Empty)
}

bool Empty::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.Empty)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:gate.Empty)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.Empty)
  return false;
#undef DO_
}

void Empty::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.Empty)
  // @@protoc_insertion_point(serialize_end:gate.Empty)
}

::google::protobuf::uint8* Empty::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.Empty)
  // @@protoc_insertion_point(serialize_to_array_end:gate.Empty)
  return target;
}

int Empty::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.Empty)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Empty::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.Empty)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const Empty* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const Empty>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.Empty)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.Empty)
    MergeFrom(*source);
  }
}

void Empty::MergeFrom(const Empty& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.Empty)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void Empty::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.Empty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Empty::CopyFrom(const Empty& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.Empty)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Empty::IsInitialized() const {

  return true;
}

void Empty::Swap(Empty* other) {
  if (other == this) return;
  InternalSwap(other);
}
void Empty::InternalSwap(Empty* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata Empty::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Empty_descriptor_;
  metadata.reflection = Empty_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// Empty

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int PushMsgReq::kKeysFieldNumber;
const int PushMsgReq::kProtoOpFieldNumber;
const int PushMsgReq::kProtoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PushMsgReq::PushMsgReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.PushMsgReq)
}

void PushMsgReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  proto_ = const_cast< ::gate::Proto*>(&::gate::Proto::default_instance());
}

PushMsgReq::PushMsgReq(const PushMsgReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.PushMsgReq)
}

void PushMsgReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  protoop_ = 0;
  proto_ = NULL;
}

PushMsgReq::~PushMsgReq() {
  // @@protoc_insertion_point(destructor:gate.PushMsgReq)
  SharedDtor();
}

void PushMsgReq::SharedDtor() {
  if (this != default_instance_) {
    delete proto_;
  }
}

void PushMsgReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushMsgReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushMsgReq_descriptor_;
}

const PushMsgReq& PushMsgReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

PushMsgReq* PushMsgReq::default_instance_ = NULL;

PushMsgReq* PushMsgReq::New(::google::protobuf::Arena* arena) const {
  PushMsgReq* n = new PushMsgReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushMsgReq::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.PushMsgReq)
  protoop_ = 0;
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
  keys_.Clear();
}

bool PushMsgReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.PushMsgReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string keys = 1;
      case 1: {
        if (tag == 10) {
         parse_keys:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_keys()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->keys(this->keys_size() - 1).data(),
            this->keys(this->keys_size() - 1).length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "gate.PushMsgReq.keys"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_keys;
        if (input->ExpectTag(18)) goto parse_proto;
        break;
      }

      // optional .gate.Proto proto = 2;
      case 2: {
        if (tag == 18) {
         parse_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_protoOp;
        break;
      }

      // optional int32 protoOp = 3;
      case 3: {
        if (tag == 24) {
         parse_protoOp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &protoop_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gate.PushMsgReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.PushMsgReq)
  return false;
#undef DO_
}

void PushMsgReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.PushMsgReq)
  // repeated string keys = 1;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->keys(i).data(), this->keys(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "gate.PushMsgReq.keys");
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->keys(i), output);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->proto_, output);
  }

  // optional int32 protoOp = 3;
  if (this->protoop() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->protoop(), output);
  }

  // @@protoc_insertion_point(serialize_end:gate.PushMsgReq)
}

::google::protobuf::uint8* PushMsgReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.PushMsgReq)
  // repeated string keys = 1;
  for (int i = 0; i < this->keys_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->keys(i).data(), this->keys(i).length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "gate.PushMsgReq.keys");
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->keys(i), target);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->proto_, false, target);
  }

  // optional int32 protoOp = 3;
  if (this->protoop() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->protoop(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:gate.PushMsgReq)
  return target;
}

int PushMsgReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.PushMsgReq)
  int total_size = 0;

  // optional int32 protoOp = 3;
  if (this->protoop() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->protoop());
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->proto_);
  }

  // repeated string keys = 1;
  total_size += 1 * this->keys_size();
  for (int i = 0; i < this->keys_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->keys(i));
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushMsgReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.PushMsgReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PushMsgReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushMsgReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.PushMsgReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.PushMsgReq)
    MergeFrom(*source);
  }
}

void PushMsgReq::MergeFrom(const PushMsgReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.PushMsgReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  keys_.MergeFrom(from.keys_);
  if (from.protoop() != 0) {
    set_protoop(from.protoop());
  }
  if (from.has_proto()) {
    mutable_proto()->::gate::Proto::MergeFrom(from.proto());
  }
}

void PushMsgReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.PushMsgReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushMsgReq::CopyFrom(const PushMsgReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.PushMsgReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushMsgReq::IsInitialized() const {

  return true;
}

void PushMsgReq::Swap(PushMsgReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushMsgReq::InternalSwap(PushMsgReq* other) {
  keys_.UnsafeArenaSwap(&other->keys_);
  std::swap(protoop_, other->protoop_);
  std::swap(proto_, other->proto_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushMsgReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushMsgReq_descriptor_;
  metadata.reflection = PushMsgReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushMsgReq

// repeated string keys = 1;
int PushMsgReq::keys_size() const {
  return keys_.size();
}
void PushMsgReq::clear_keys() {
  keys_.Clear();
}
 const ::std::string& PushMsgReq::keys(int index) const {
  // @@protoc_insertion_point(field_get:gate.PushMsgReq.keys)
  return keys_.Get(index);
}
 ::std::string* PushMsgReq::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:gate.PushMsgReq.keys)
  return keys_.Mutable(index);
}
 void PushMsgReq::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:gate.PushMsgReq.keys)
  keys_.Mutable(index)->assign(value);
}
 void PushMsgReq::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:gate.PushMsgReq.keys)
}
 void PushMsgReq::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:gate.PushMsgReq.keys)
}
 ::std::string* PushMsgReq::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:gate.PushMsgReq.keys)
  return keys_.Add();
}
 void PushMsgReq::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:gate.PushMsgReq.keys)
}
 void PushMsgReq::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:gate.PushMsgReq.keys)
}
 void PushMsgReq::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:gate.PushMsgReq.keys)
}
 const ::google::protobuf::RepeatedPtrField< ::std::string>&
PushMsgReq::keys() const {
  // @@protoc_insertion_point(field_list:gate.PushMsgReq.keys)
  return keys_;
}
 ::google::protobuf::RepeatedPtrField< ::std::string>*
PushMsgReq::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:gate.PushMsgReq.keys)
  return &keys_;
}

// optional int32 protoOp = 3;
void PushMsgReq::clear_protoop() {
  protoop_ = 0;
}
 ::google::protobuf::int32 PushMsgReq::protoop() const {
  // @@protoc_insertion_point(field_get:gate.PushMsgReq.protoOp)
  return protoop_;
}
 void PushMsgReq::set_protoop(::google::protobuf::int32 value) {
  
  protoop_ = value;
  // @@protoc_insertion_point(field_set:gate.PushMsgReq.protoOp)
}

// optional .gate.Proto proto = 2;
bool PushMsgReq::has_proto() const {
  return !_is_default_instance_ && proto_ != NULL;
}
void PushMsgReq::clear_proto() {
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}
const ::gate::Proto& PushMsgReq::proto() const {
  // @@protoc_insertion_point(field_get:gate.PushMsgReq.proto)
  return proto_ != NULL ? *proto_ : *default_instance_->proto_;
}
::gate::Proto* PushMsgReq::mutable_proto() {
  
  if (proto_ == NULL) {
    proto_ = new ::gate::Proto;
  }
  // @@protoc_insertion_point(field_mutable:gate.PushMsgReq.proto)
  return proto_;
}
::gate::Proto* PushMsgReq::release_proto() {
  // @@protoc_insertion_point(field_release:gate.PushMsgReq.proto)
  
  ::gate::Proto* temp = proto_;
  proto_ = NULL;
  return temp;
}
void PushMsgReq::set_allocated_proto(::gate::Proto* proto) {
  delete proto_;
  proto_ = proto;
  if (proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:gate.PushMsgReq.proto)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

PushMsgReply::PushMsgReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.PushMsgReply)
}

void PushMsgReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

PushMsgReply::PushMsgReply(const PushMsgReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.PushMsgReply)
}

void PushMsgReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

PushMsgReply::~PushMsgReply() {
  // @@protoc_insertion_point(destructor:gate.PushMsgReply)
  SharedDtor();
}

void PushMsgReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PushMsgReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PushMsgReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PushMsgReply_descriptor_;
}

const PushMsgReply& PushMsgReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

PushMsgReply* PushMsgReply::default_instance_ = NULL;

PushMsgReply* PushMsgReply::New(::google::protobuf::Arena* arena) const {
  PushMsgReply* n = new PushMsgReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void PushMsgReply::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.PushMsgReply)
}

bool PushMsgReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.PushMsgReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:gate.PushMsgReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.PushMsgReply)
  return false;
#undef DO_
}

void PushMsgReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.PushMsgReply)
  // @@protoc_insertion_point(serialize_end:gate.PushMsgReply)
}

::google::protobuf::uint8* PushMsgReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.PushMsgReply)
  // @@protoc_insertion_point(serialize_to_array_end:gate.PushMsgReply)
  return target;
}

int PushMsgReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.PushMsgReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PushMsgReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.PushMsgReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const PushMsgReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const PushMsgReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.PushMsgReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.PushMsgReply)
    MergeFrom(*source);
  }
}

void PushMsgReply::MergeFrom(const PushMsgReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.PushMsgReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void PushMsgReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.PushMsgReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PushMsgReply::CopyFrom(const PushMsgReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.PushMsgReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PushMsgReply::IsInitialized() const {

  return true;
}

void PushMsgReply::Swap(PushMsgReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void PushMsgReply::InternalSwap(PushMsgReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata PushMsgReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PushMsgReply_descriptor_;
  metadata.reflection = PushMsgReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// PushMsgReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BroadcastReq::kProtoOpFieldNumber;
const int BroadcastReq::kProtoFieldNumber;
const int BroadcastReq::kSpeedFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BroadcastReq::BroadcastReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.BroadcastReq)
}

void BroadcastReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  proto_ = const_cast< ::gate::Proto*>(&::gate::Proto::default_instance());
}

BroadcastReq::BroadcastReq(const BroadcastReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.BroadcastReq)
}

void BroadcastReq::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
  protoop_ = 0;
  proto_ = NULL;
  speed_ = 0;
}

BroadcastReq::~BroadcastReq() {
  // @@protoc_insertion_point(destructor:gate.BroadcastReq)
  SharedDtor();
}

void BroadcastReq::SharedDtor() {
  if (this != default_instance_) {
    delete proto_;
  }
}

void BroadcastReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BroadcastReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BroadcastReq_descriptor_;
}

const BroadcastReq& BroadcastReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

BroadcastReq* BroadcastReq::default_instance_ = NULL;

BroadcastReq* BroadcastReq::New(::google::protobuf::Arena* arena) const {
  BroadcastReq* n = new BroadcastReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BroadcastReq::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.BroadcastReq)
#if defined(__clang__)
#define ZR_HELPER_(f) \
  _Pragma("clang diagnostic push") \
  _Pragma("clang diagnostic ignored \"-Winvalid-offsetof\"") \
  __builtin_offsetof(BroadcastReq, f) \
  _Pragma("clang diagnostic pop")
#else
#define ZR_HELPER_(f) reinterpret_cast<char*>(\
  &reinterpret_cast<BroadcastReq*>(16)->f)
#endif

#define ZR_(first, last) do {\
  ::memset(&first, 0,\
           ZR_HELPER_(last) - ZR_HELPER_(first) + sizeof(last));\
} while (0)

  ZR_(protoop_, speed_);
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;

#undef ZR_HELPER_
#undef ZR_

}

bool BroadcastReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.BroadcastReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 protoOp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &protoop_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_proto;
        break;
      }

      // optional .gate.Proto proto = 2;
      case 2: {
        if (tag == 18) {
         parse_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_speed;
        break;
      }

      // optional int32 speed = 3;
      case 3: {
        if (tag == 24) {
         parse_speed:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &speed_)));

        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gate.BroadcastReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.BroadcastReq)
  return false;
#undef DO_
}

void BroadcastReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.BroadcastReq)
  // optional int32 protoOp = 1;
  if (this->protoop() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->protoop(), output);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->proto_, output);
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->speed(), output);
  }

  // @@protoc_insertion_point(serialize_end:gate.BroadcastReq)
}

::google::protobuf::uint8* BroadcastReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.BroadcastReq)
  // optional int32 protoOp = 1;
  if (this->protoop() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->protoop(), target);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->proto_, false, target);
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->speed(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:gate.BroadcastReq)
  return target;
}

int BroadcastReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.BroadcastReq)
  int total_size = 0;

  // optional int32 protoOp = 1;
  if (this->protoop() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->protoop());
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->proto_);
  }

  // optional int32 speed = 3;
  if (this->speed() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->speed());
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.BroadcastReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BroadcastReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BroadcastReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.BroadcastReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.BroadcastReq)
    MergeFrom(*source);
  }
}

void BroadcastReq::MergeFrom(const BroadcastReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.BroadcastReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.protoop() != 0) {
    set_protoop(from.protoop());
  }
  if (from.has_proto()) {
    mutable_proto()->::gate::Proto::MergeFrom(from.proto());
  }
  if (from.speed() != 0) {
    set_speed(from.speed());
  }
}

void BroadcastReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.BroadcastReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BroadcastReq::CopyFrom(const BroadcastReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.BroadcastReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastReq::IsInitialized() const {

  return true;
}

void BroadcastReq::Swap(BroadcastReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BroadcastReq::InternalSwap(BroadcastReq* other) {
  std::swap(protoop_, other->protoop_);
  std::swap(proto_, other->proto_);
  std::swap(speed_, other->speed_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BroadcastReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BroadcastReq_descriptor_;
  metadata.reflection = BroadcastReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BroadcastReq

// optional int32 protoOp = 1;
void BroadcastReq::clear_protoop() {
  protoop_ = 0;
}
 ::google::protobuf::int32 BroadcastReq::protoop() const {
  // @@protoc_insertion_point(field_get:gate.BroadcastReq.protoOp)
  return protoop_;
}
 void BroadcastReq::set_protoop(::google::protobuf::int32 value) {
  
  protoop_ = value;
  // @@protoc_insertion_point(field_set:gate.BroadcastReq.protoOp)
}

// optional .gate.Proto proto = 2;
bool BroadcastReq::has_proto() const {
  return !_is_default_instance_ && proto_ != NULL;
}
void BroadcastReq::clear_proto() {
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}
const ::gate::Proto& BroadcastReq::proto() const {
  // @@protoc_insertion_point(field_get:gate.BroadcastReq.proto)
  return proto_ != NULL ? *proto_ : *default_instance_->proto_;
}
::gate::Proto* BroadcastReq::mutable_proto() {
  
  if (proto_ == NULL) {
    proto_ = new ::gate::Proto;
  }
  // @@protoc_insertion_point(field_mutable:gate.BroadcastReq.proto)
  return proto_;
}
::gate::Proto* BroadcastReq::release_proto() {
  // @@protoc_insertion_point(field_release:gate.BroadcastReq.proto)
  
  ::gate::Proto* temp = proto_;
  proto_ = NULL;
  return temp;
}
void BroadcastReq::set_allocated_proto(::gate::Proto* proto) {
  delete proto_;
  proto_ = proto;
  if (proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:gate.BroadcastReq.proto)
}

// optional int32 speed = 3;
void BroadcastReq::clear_speed() {
  speed_ = 0;
}
 ::google::protobuf::int32 BroadcastReq::speed() const {
  // @@protoc_insertion_point(field_get:gate.BroadcastReq.speed)
  return speed_;
}
 void BroadcastReq::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:gate.BroadcastReq.speed)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BroadcastReply::BroadcastReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.BroadcastReply)
}

void BroadcastReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

BroadcastReply::BroadcastReply(const BroadcastReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.BroadcastReply)
}

void BroadcastReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

BroadcastReply::~BroadcastReply() {
  // @@protoc_insertion_point(destructor:gate.BroadcastReply)
  SharedDtor();
}

void BroadcastReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BroadcastReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BroadcastReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BroadcastReply_descriptor_;
}

const BroadcastReply& BroadcastReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

BroadcastReply* BroadcastReply::default_instance_ = NULL;

BroadcastReply* BroadcastReply::New(::google::protobuf::Arena* arena) const {
  BroadcastReply* n = new BroadcastReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BroadcastReply::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.BroadcastReply)
}

bool BroadcastReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.BroadcastReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:gate.BroadcastReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.BroadcastReply)
  return false;
#undef DO_
}

void BroadcastReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.BroadcastReply)
  // @@protoc_insertion_point(serialize_end:gate.BroadcastReply)
}

::google::protobuf::uint8* BroadcastReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.BroadcastReply)
  // @@protoc_insertion_point(serialize_to_array_end:gate.BroadcastReply)
  return target;
}

int BroadcastReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.BroadcastReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.BroadcastReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BroadcastReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BroadcastReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.BroadcastReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.BroadcastReply)
    MergeFrom(*source);
  }
}

void BroadcastReply::MergeFrom(const BroadcastReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.BroadcastReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void BroadcastReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.BroadcastReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BroadcastReply::CopyFrom(const BroadcastReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.BroadcastReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastReply::IsInitialized() const {

  return true;
}

void BroadcastReply::Swap(BroadcastReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BroadcastReply::InternalSwap(BroadcastReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BroadcastReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BroadcastReply_descriptor_;
  metadata.reflection = BroadcastReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BroadcastReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int BroadcastRoomReq::kRoomIDFieldNumber;
const int BroadcastRoomReq::kProtoFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BroadcastRoomReq::BroadcastRoomReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.BroadcastRoomReq)
}

void BroadcastRoomReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
  proto_ = const_cast< ::gate::Proto*>(&::gate::Proto::default_instance());
}

BroadcastRoomReq::BroadcastRoomReq(const BroadcastRoomReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.BroadcastRoomReq)
}

void BroadcastRoomReq::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  roomid_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  proto_ = NULL;
}

BroadcastRoomReq::~BroadcastRoomReq() {
  // @@protoc_insertion_point(destructor:gate.BroadcastRoomReq)
  SharedDtor();
}

void BroadcastRoomReq::SharedDtor() {
  roomid_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != default_instance_) {
    delete proto_;
  }
}

void BroadcastRoomReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BroadcastRoomReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BroadcastRoomReq_descriptor_;
}

const BroadcastRoomReq& BroadcastRoomReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

BroadcastRoomReq* BroadcastRoomReq::default_instance_ = NULL;

BroadcastRoomReq* BroadcastRoomReq::New(::google::protobuf::Arena* arena) const {
  BroadcastRoomReq* n = new BroadcastRoomReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BroadcastRoomReq::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.BroadcastRoomReq)
  roomid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}

bool BroadcastRoomReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.BroadcastRoomReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string roomID = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_roomid()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->roomid().data(), this->roomid().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "gate.BroadcastRoomReq.roomID"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_proto;
        break;
      }

      // optional .gate.Proto proto = 2;
      case 2: {
        if (tag == 18) {
         parse_proto:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_proto()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gate.BroadcastRoomReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.BroadcastRoomReq)
  return false;
#undef DO_
}

void BroadcastRoomReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.BroadcastRoomReq)
  // optional string roomID = 1;
  if (this->roomid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->roomid().data(), this->roomid().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "gate.BroadcastRoomReq.roomID");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->roomid(), output);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, *this->proto_, output);
  }

  // @@protoc_insertion_point(serialize_end:gate.BroadcastRoomReq)
}

::google::protobuf::uint8* BroadcastRoomReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.BroadcastRoomReq)
  // optional string roomID = 1;
  if (this->roomid().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->roomid().data(), this->roomid().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "gate.BroadcastRoomReq.roomID");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->roomid(), target);
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        2, *this->proto_, false, target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:gate.BroadcastRoomReq)
  return target;
}

int BroadcastRoomReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.BroadcastRoomReq)
  int total_size = 0;

  // optional string roomID = 1;
  if (this->roomid().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->roomid());
  }

  // optional .gate.Proto proto = 2;
  if (this->has_proto()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->proto_);
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastRoomReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.BroadcastRoomReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BroadcastRoomReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BroadcastRoomReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.BroadcastRoomReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.BroadcastRoomReq)
    MergeFrom(*source);
  }
}

void BroadcastRoomReq::MergeFrom(const BroadcastRoomReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.BroadcastRoomReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  if (from.roomid().size() > 0) {

    roomid_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.roomid_);
  }
  if (from.has_proto()) {
    mutable_proto()->::gate::Proto::MergeFrom(from.proto());
  }
}

void BroadcastRoomReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.BroadcastRoomReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BroadcastRoomReq::CopyFrom(const BroadcastRoomReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.BroadcastRoomReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastRoomReq::IsInitialized() const {

  return true;
}

void BroadcastRoomReq::Swap(BroadcastRoomReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BroadcastRoomReq::InternalSwap(BroadcastRoomReq* other) {
  roomid_.Swap(&other->roomid_);
  std::swap(proto_, other->proto_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BroadcastRoomReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BroadcastRoomReq_descriptor_;
  metadata.reflection = BroadcastRoomReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BroadcastRoomReq

// optional string roomID = 1;
void BroadcastRoomReq::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 const ::std::string& BroadcastRoomReq::roomid() const {
  // @@protoc_insertion_point(field_get:gate.BroadcastRoomReq.roomID)
  return roomid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BroadcastRoomReq::set_roomid(const ::std::string& value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:gate.BroadcastRoomReq.roomID)
}
 void BroadcastRoomReq::set_roomid(const char* value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:gate.BroadcastRoomReq.roomID)
}
 void BroadcastRoomReq::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:gate.BroadcastRoomReq.roomID)
}
 ::std::string* BroadcastRoomReq::mutable_roomid() {
  
  // @@protoc_insertion_point(field_mutable:gate.BroadcastRoomReq.roomID)
  return roomid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 ::std::string* BroadcastRoomReq::release_roomid() {
  // @@protoc_insertion_point(field_release:gate.BroadcastRoomReq.roomID)
  
  return roomid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
 void BroadcastRoomReq::set_allocated_roomid(::std::string* roomid) {
  if (roomid != NULL) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:gate.BroadcastRoomReq.roomID)
}

// optional .gate.Proto proto = 2;
bool BroadcastRoomReq::has_proto() const {
  return !_is_default_instance_ && proto_ != NULL;
}
void BroadcastRoomReq::clear_proto() {
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}
const ::gate::Proto& BroadcastRoomReq::proto() const {
  // @@protoc_insertion_point(field_get:gate.BroadcastRoomReq.proto)
  return proto_ != NULL ? *proto_ : *default_instance_->proto_;
}
::gate::Proto* BroadcastRoomReq::mutable_proto() {
  
  if (proto_ == NULL) {
    proto_ = new ::gate::Proto;
  }
  // @@protoc_insertion_point(field_mutable:gate.BroadcastRoomReq.proto)
  return proto_;
}
::gate::Proto* BroadcastRoomReq::release_proto() {
  // @@protoc_insertion_point(field_release:gate.BroadcastRoomReq.proto)
  
  ::gate::Proto* temp = proto_;
  proto_ = NULL;
  return temp;
}
void BroadcastRoomReq::set_allocated_proto(::gate::Proto* proto) {
  delete proto_;
  proto_ = proto;
  if (proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:gate.BroadcastRoomReq.proto)
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

BroadcastRoomReply::BroadcastRoomReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.BroadcastRoomReply)
}

void BroadcastRoomReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

BroadcastRoomReply::BroadcastRoomReply(const BroadcastRoomReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.BroadcastRoomReply)
}

void BroadcastRoomReply::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

BroadcastRoomReply::~BroadcastRoomReply() {
  // @@protoc_insertion_point(destructor:gate.BroadcastRoomReply)
  SharedDtor();
}

void BroadcastRoomReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void BroadcastRoomReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* BroadcastRoomReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return BroadcastRoomReply_descriptor_;
}

const BroadcastRoomReply& BroadcastRoomReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

BroadcastRoomReply* BroadcastRoomReply::default_instance_ = NULL;

BroadcastRoomReply* BroadcastRoomReply::New(::google::protobuf::Arena* arena) const {
  BroadcastRoomReply* n = new BroadcastRoomReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void BroadcastRoomReply::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.BroadcastRoomReply)
}

bool BroadcastRoomReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.BroadcastRoomReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:gate.BroadcastRoomReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.BroadcastRoomReply)
  return false;
#undef DO_
}

void BroadcastRoomReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.BroadcastRoomReply)
  // @@protoc_insertion_point(serialize_end:gate.BroadcastRoomReply)
}

::google::protobuf::uint8* BroadcastRoomReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.BroadcastRoomReply)
  // @@protoc_insertion_point(serialize_to_array_end:gate.BroadcastRoomReply)
  return target;
}

int BroadcastRoomReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.BroadcastRoomReply)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void BroadcastRoomReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.BroadcastRoomReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const BroadcastRoomReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const BroadcastRoomReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.BroadcastRoomReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.BroadcastRoomReply)
    MergeFrom(*source);
  }
}

void BroadcastRoomReply::MergeFrom(const BroadcastRoomReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.BroadcastRoomReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void BroadcastRoomReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.BroadcastRoomReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void BroadcastRoomReply::CopyFrom(const BroadcastRoomReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.BroadcastRoomReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool BroadcastRoomReply::IsInitialized() const {

  return true;
}

void BroadcastRoomReply::Swap(BroadcastRoomReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void BroadcastRoomReply::InternalSwap(BroadcastRoomReply* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata BroadcastRoomReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = BroadcastRoomReply_descriptor_;
  metadata.reflection = BroadcastRoomReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// BroadcastRoomReply

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoomsReq::RoomsReq()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.RoomsReq)
}

void RoomsReq::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

RoomsReq::RoomsReq(const RoomsReq& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.RoomsReq)
}

void RoomsReq::SharedCtor() {
    _is_default_instance_ = false;
  _cached_size_ = 0;
}

RoomsReq::~RoomsReq() {
  // @@protoc_insertion_point(destructor:gate.RoomsReq)
  SharedDtor();
}

void RoomsReq::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RoomsReq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoomsReq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoomsReq_descriptor_;
}

const RoomsReq& RoomsReq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

RoomsReq* RoomsReq::default_instance_ = NULL;

RoomsReq* RoomsReq::New(::google::protobuf::Arena* arena) const {
  RoomsReq* n = new RoomsReq;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoomsReq::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.RoomsReq)
}

bool RoomsReq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.RoomsReq)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
  handle_unusual:
    if (tag == 0 ||
        ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
        ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
      goto success;
    }
    DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
  }
success:
  // @@protoc_insertion_point(parse_success:gate.RoomsReq)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.RoomsReq)
  return false;
#undef DO_
}

void RoomsReq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.RoomsReq)
  // @@protoc_insertion_point(serialize_end:gate.RoomsReq)
}

::google::protobuf::uint8* RoomsReq::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.RoomsReq)
  // @@protoc_insertion_point(serialize_to_array_end:gate.RoomsReq)
  return target;
}

int RoomsReq::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.RoomsReq)
  int total_size = 0;

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoomsReq::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.RoomsReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RoomsReq* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RoomsReq>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.RoomsReq)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.RoomsReq)
    MergeFrom(*source);
  }
}

void RoomsReq::MergeFrom(const RoomsReq& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.RoomsReq)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
}

void RoomsReq::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.RoomsReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoomsReq::CopyFrom(const RoomsReq& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.RoomsReq)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomsReq::IsInitialized() const {

  return true;
}

void RoomsReq::Swap(RoomsReq* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoomsReq::InternalSwap(RoomsReq* other) {
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoomsReq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoomsReq_descriptor_;
  metadata.reflection = RoomsReq_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RoomsReq

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int RoomsReply::kRoomsFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

RoomsReply::RoomsReply()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:gate.RoomsReply)
}

void RoomsReply::InitAsDefaultInstance() {
  _is_default_instance_ = true;
}

RoomsReply::RoomsReply(const RoomsReply& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:gate.RoomsReply)
}

void RoomsReply::SharedCtor() {
    _is_default_instance_ = false;
  ::google::protobuf::internal::GetEmptyString();
  _cached_size_ = 0;
  rooms_.SetAssignDescriptorCallback(
      protobuf_AssignDescriptorsOnce);
  rooms_.SetEntryDescriptor(
      &::gate::RoomsReply_RoomsEntry_descriptor_);
}

RoomsReply::~RoomsReply() {
  // @@protoc_insertion_point(destructor:gate.RoomsReply)
  SharedDtor();
}

void RoomsReply::SharedDtor() {
  if (this != default_instance_) {
  }
}

void RoomsReply::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RoomsReply::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RoomsReply_descriptor_;
}

const RoomsReply& RoomsReply::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_gate_2eproto();
  return *default_instance_;
}

RoomsReply* RoomsReply::default_instance_ = NULL;

RoomsReply* RoomsReply::New(::google::protobuf::Arena* arena) const {
  RoomsReply* n = new RoomsReply;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void RoomsReply::Clear() {
// @@protoc_insertion_point(message_clear_start:gate.RoomsReply)
  rooms_.Clear();
}

bool RoomsReply::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:gate.RoomsReply)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // map<string, bool> rooms = 1;
      case 1: {
        if (tag == 10) {
          DO_(input->IncrementRecursionDepth());
         parse_loop_rooms:
          RoomsReply_RoomsEntry::Parser< ::google::protobuf::internal::MapField<
              ::std::string, bool,
              ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
              ::google::protobuf::internal::WireFormatLite::TYPE_BOOL,
              0 >,
            ::google::protobuf::Map< ::std::string, bool > > parser(&rooms_);
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
              input, &parser));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            parser.key().data(), parser.key().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "gate.RoomsReply.RoomsEntry.key"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(10)) goto parse_loop_rooms;
        input->UnsafeDecrementRecursionDepth();
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:gate.RoomsReply)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:gate.RoomsReply)
  return false;
#undef DO_
}

void RoomsReply::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:gate.RoomsReply)
  // map<string, bool> rooms = 1;
  if (!this->rooms().empty()) {
    typedef ::google::protobuf::Map< ::std::string, bool >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "gate.RoomsReply.RoomsEntry.key");
      }
    };

    if (output->IsSerializationDeterminstic() &&
        this->rooms().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->rooms().size()]);
      typedef ::google::protobuf::Map< ::std::string, bool >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, bool >::const_iterator
          it = this->rooms().begin();
          it != this->rooms().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<RoomsReply_RoomsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(rooms_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<RoomsReply_RoomsEntry> entry;
      for (::google::protobuf::Map< ::std::string, bool >::const_iterator
          it = this->rooms().begin();
          it != this->rooms().end(); ++it) {
        entry.reset(rooms_.NewEntryWrapper(
            it->first, it->second));
        ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
            1, *entry, output);
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_end:gate.RoomsReply)
}

::google::protobuf::uint8* RoomsReply::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:gate.RoomsReply)
  // map<string, bool> rooms = 1;
  if (!this->rooms().empty()) {
    typedef ::google::protobuf::Map< ::std::string, bool >::const_pointer
        ConstPtr;
    typedef ConstPtr SortItem;
    typedef ::google::protobuf::internal::CompareByDerefFirst<SortItem> Less;
    struct Utf8Check {
      static void Check(ConstPtr p) {
        ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
          p->first.data(), p->first.length(),
          ::google::protobuf::internal::WireFormatLite::SERIALIZE,
          "gate.RoomsReply.RoomsEntry.key");
      }
    };

    if (deterministic &&
        this->rooms().size() > 1) {
      ::google::protobuf::scoped_array<SortItem> items(
          new SortItem[this->rooms().size()]);
      typedef ::google::protobuf::Map< ::std::string, bool >::size_type size_type;
      size_type n = 0;
      for (::google::protobuf::Map< ::std::string, bool >::const_iterator
          it = this->rooms().begin();
          it != this->rooms().end(); ++it, ++n) {
        items[n] = SortItem(&*it);
      }
      ::std::sort(&items[0], &items[n], Less());
      ::google::protobuf::scoped_ptr<RoomsReply_RoomsEntry> entry;
      for (size_type i = 0; i < n; i++) {
        entry.reset(rooms_.NewEntryWrapper(
            items[i]->first, items[i]->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(items[i]);
      }
    } else {
      ::google::protobuf::scoped_ptr<RoomsReply_RoomsEntry> entry;
      for (::google::protobuf::Map< ::std::string, bool >::const_iterator
          it = this->rooms().begin();
          it != this->rooms().end(); ++it) {
        entry.reset(rooms_.NewEntryWrapper(
            it->first, it->second));
        target = ::google::protobuf::internal::WireFormatLite::
                   InternalWriteMessageNoVirtualToArray(
                       1, *entry, deterministic, target);
;
        Utf8Check::Check(&*it);
      }
    }
  }

  // @@protoc_insertion_point(serialize_to_array_end:gate.RoomsReply)
  return target;
}

int RoomsReply::ByteSize() const {
// @@protoc_insertion_point(message_byte_size_start:gate.RoomsReply)
  int total_size = 0;

  // map<string, bool> rooms = 1;
  total_size += 1 * this->rooms_size();
  {
    ::google::protobuf::scoped_ptr<RoomsReply_RoomsEntry> entry;
    for (::google::protobuf::Map< ::std::string, bool >::const_iterator
        it = this->rooms().begin();
        it != this->rooms().end(); ++it) {
      entry.reset(rooms_.NewEntryWrapper(it->first, it->second));
      total_size += ::google::protobuf::internal::WireFormatLite::
          MessageSizeNoVirtual(*entry);
    }
  }

  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RoomsReply::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:gate.RoomsReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  const RoomsReply* source = 
      ::google::protobuf::internal::DynamicCastToGenerated<const RoomsReply>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:gate.RoomsReply)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:gate.RoomsReply)
    MergeFrom(*source);
  }
}

void RoomsReply::MergeFrom(const RoomsReply& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:gate.RoomsReply)
  if (GOOGLE_PREDICT_FALSE(&from == this)) {
    ::google::protobuf::internal::MergeFromFail(__FILE__, __LINE__);
  }
  rooms_.MergeFrom(from.rooms_);
}

void RoomsReply::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:gate.RoomsReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RoomsReply::CopyFrom(const RoomsReply& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:gate.RoomsReply)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RoomsReply::IsInitialized() const {

  return true;
}

void RoomsReply::Swap(RoomsReply* other) {
  if (other == this) return;
  InternalSwap(other);
}
void RoomsReply::InternalSwap(RoomsReply* other) {
  rooms_.Swap(&other->rooms_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata RoomsReply::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RoomsReply_descriptor_;
  metadata.reflection = RoomsReply_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// RoomsReply

// map<string, bool> rooms = 1;
int RoomsReply::rooms_size() const {
  return rooms_.size();
}
void RoomsReply::clear_rooms() {
  rooms_.Clear();
}
 const ::google::protobuf::Map< ::std::string, bool >&
RoomsReply::rooms() const {
  // @@protoc_insertion_point(field_map:gate.RoomsReply.rooms)
  return rooms_.GetMap();
}
 ::google::protobuf::Map< ::std::string, bool >*
RoomsReply::mutable_rooms() {
  // @@protoc_insertion_point(field_mutable_map:gate.RoomsReply.rooms)
  return rooms_.MutableMap();
}

#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

Gate::~Gate() {}

const ::google::protobuf::ServiceDescriptor* Gate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Gate_descriptor_;
}

const ::google::protobuf::ServiceDescriptor* Gate::GetDescriptor() {
  protobuf_AssignDescriptorsOnce();
  return Gate_descriptor_;
}

void Gate::Ping(::google::protobuf::RpcController* controller,
                         const ::gate::Empty*,
                         ::gate::Empty*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Ping() not implemented.");
  done->Run();
}

void Gate::Close(::google::protobuf::RpcController* controller,
                         const ::gate::Empty*,
                         ::gate::Empty*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Close() not implemented.");
  done->Run();
}

void Gate::PushMsg(::google::protobuf::RpcController* controller,
                         const ::gate::PushMsgReq*,
                         ::gate::PushMsgReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method PushMsg() not implemented.");
  done->Run();
}

void Gate::Broadcast(::google::protobuf::RpcController* controller,
                         const ::gate::BroadcastReq*,
                         ::gate::BroadcastReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Broadcast() not implemented.");
  done->Run();
}

void Gate::BroadcastRoom(::google::protobuf::RpcController* controller,
                         const ::gate::BroadcastRoomReq*,
                         ::gate::BroadcastRoomReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method BroadcastRoom() not implemented.");
  done->Run();
}

void Gate::Rooms(::google::protobuf::RpcController* controller,
                         const ::gate::RoomsReq*,
                         ::gate::RoomsReply*,
                         ::google::protobuf::Closure* done) {
  controller->SetFailed("Method Rooms() not implemented.");
  done->Run();
}

void Gate::CallMethod(const ::google::protobuf::MethodDescriptor* method,
                             ::google::protobuf::RpcController* controller,
                             const ::google::protobuf::Message* request,
                             ::google::protobuf::Message* response,
                             ::google::protobuf::Closure* done) {
  GOOGLE_DCHECK_EQ(method->service(), Gate_descriptor_);
  switch(method->index()) {
    case 0:
      Ping(controller,
             ::google::protobuf::down_cast<const ::gate::Empty*>(request),
             ::google::protobuf::down_cast< ::gate::Empty*>(response),
             done);
      break;
    case 1:
      Close(controller,
             ::google::protobuf::down_cast<const ::gate::Empty*>(request),
             ::google::protobuf::down_cast< ::gate::Empty*>(response),
             done);
      break;
    case 2:
      PushMsg(controller,
             ::google::protobuf::down_cast<const ::gate::PushMsgReq*>(request),
             ::google::protobuf::down_cast< ::gate::PushMsgReply*>(response),
             done);
      break;
    case 3:
      Broadcast(controller,
             ::google::protobuf::down_cast<const ::gate::BroadcastReq*>(request),
             ::google::protobuf::down_cast< ::gate::BroadcastReply*>(response),
             done);
      break;
    case 4:
      BroadcastRoom(controller,
             ::google::protobuf::down_cast<const ::gate::BroadcastRoomReq*>(request),
             ::google::protobuf::down_cast< ::gate::BroadcastRoomReply*>(response),
             done);
      break;
    case 5:
      Rooms(controller,
             ::google::protobuf::down_cast<const ::gate::RoomsReq*>(request),
             ::google::protobuf::down_cast< ::gate::RoomsReply*>(response),
             done);
      break;
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      break;
  }
}

const ::google::protobuf::Message& Gate::GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::gate::Empty::default_instance();
    case 1:
      return ::gate::Empty::default_instance();
    case 2:
      return ::gate::PushMsgReq::default_instance();
    case 3:
      return ::gate::BroadcastReq::default_instance();
    case 4:
      return ::gate::BroadcastRoomReq::default_instance();
    case 5:
      return ::gate::RoomsReq::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->input_type());
  }
}

const ::google::protobuf::Message& Gate::GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const {
  GOOGLE_DCHECK_EQ(method->service(), descriptor());
  switch(method->index()) {
    case 0:
      return ::gate::Empty::default_instance();
    case 1:
      return ::gate::Empty::default_instance();
    case 2:
      return ::gate::PushMsgReply::default_instance();
    case 3:
      return ::gate::BroadcastReply::default_instance();
    case 4:
      return ::gate::BroadcastRoomReply::default_instance();
    case 5:
      return ::gate::RoomsReply::default_instance();
    default:
      GOOGLE_LOG(FATAL) << "Bad method index; this should never happen.";
      return *::google::protobuf::MessageFactory::generated_factory()
          ->GetPrototype(method->output_type());
  }
}

Gate_Stub::Gate_Stub(::google::protobuf::RpcChannel* channel)
  : channel_(channel), owns_channel_(false) {}
Gate_Stub::Gate_Stub(
    ::google::protobuf::RpcChannel* channel,
    ::google::protobuf::Service::ChannelOwnership ownership)
  : channel_(channel),
    owns_channel_(ownership == ::google::protobuf::Service::STUB_OWNS_CHANNEL) {}
Gate_Stub::~Gate_Stub() {
  if (owns_channel_) delete channel_;
}

void Gate_Stub::Ping(::google::protobuf::RpcController* controller,
                              const ::gate::Empty* request,
                              ::gate::Empty* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(0),
                       controller, request, response, done);
}
void Gate_Stub::Close(::google::protobuf::RpcController* controller,
                              const ::gate::Empty* request,
                              ::gate::Empty* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(1),
                       controller, request, response, done);
}
void Gate_Stub::PushMsg(::google::protobuf::RpcController* controller,
                              const ::gate::PushMsgReq* request,
                              ::gate::PushMsgReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(2),
                       controller, request, response, done);
}
void Gate_Stub::Broadcast(::google::protobuf::RpcController* controller,
                              const ::gate::BroadcastReq* request,
                              ::gate::BroadcastReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(3),
                       controller, request, response, done);
}
void Gate_Stub::BroadcastRoom(::google::protobuf::RpcController* controller,
                              const ::gate::BroadcastRoomReq* request,
                              ::gate::BroadcastRoomReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(4),
                       controller, request, response, done);
}
void Gate_Stub::Rooms(::google::protobuf::RpcController* controller,
                              const ::gate::RoomsReq* request,
                              ::gate::RoomsReply* response,
                              ::google::protobuf::Closure* done) {
  channel_->CallMethod(descriptor()->method(5),
                       controller, request, response, done);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace gate

// @@protoc_insertion_point(global_scope)
