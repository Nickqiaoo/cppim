// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: logic.proto

#ifndef PROTOBUF_logic_2eproto__INCLUDED
#define PROTOBUF_logic_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/map.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/service.h>
#include <google/protobuf/unknown_field_set.h>
#include "gate.pb.h"
// @@protoc_insertion_point(includes)

namespace logic {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_logic_2eproto();
void protobuf_AssignDesc_logic_2eproto();
void protobuf_ShutdownFile_logic_2eproto();

class CloseReply;
class CloseReq;
class ConnectReply;
class ConnectReq;
class DisconnectReply;
class DisconnectReq;
class HeartbeatReply;
class HeartbeatReq;
class OnlineReply;
class OnlineReq;
class PingReply;
class PingReq;
class PushMsg;
class ReceiveReply;
class ReceiveReq;

enum PushMsg_Type {
  PushMsg_Type_PUSH = 0,
  PushMsg_Type_ROOM = 1,
  PushMsg_Type_BROADCAST = 2,
  PushMsg_Type_PushMsg_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  PushMsg_Type_PushMsg_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool PushMsg_Type_IsValid(int value);
const PushMsg_Type PushMsg_Type_Type_MIN = PushMsg_Type_PUSH;
const PushMsg_Type PushMsg_Type_Type_MAX = PushMsg_Type_BROADCAST;
const int PushMsg_Type_Type_ARRAYSIZE = PushMsg_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* PushMsg_Type_descriptor();
inline const ::std::string& PushMsg_Type_Name(PushMsg_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    PushMsg_Type_descriptor(), value);
}
inline bool PushMsg_Type_Parse(
    const ::std::string& name, PushMsg_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PushMsg_Type>(
    PushMsg_Type_descriptor(), name, value);
}
// ===================================================================

class PushMsg : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.PushMsg) */ {
 public:
  PushMsg();
  virtual ~PushMsg();

  PushMsg(const PushMsg& from);

  inline PushMsg& operator=(const PushMsg& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PushMsg& default_instance();

  void Swap(PushMsg* other);

  // implements Message ----------------------------------------------

  inline PushMsg* New() const { return New(NULL); }

  PushMsg* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PushMsg& from);
  void MergeFrom(const PushMsg& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PushMsg* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PushMsg_Type Type;
  static const Type PUSH =
    PushMsg_Type_PUSH;
  static const Type ROOM =
    PushMsg_Type_ROOM;
  static const Type BROADCAST =
    PushMsg_Type_BROADCAST;
  static inline bool Type_IsValid(int value) {
    return PushMsg_Type_IsValid(value);
  }
  static const Type Type_MIN =
    PushMsg_Type_Type_MIN;
  static const Type Type_MAX =
    PushMsg_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    PushMsg_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return PushMsg_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return PushMsg_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return PushMsg_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .logic.PushMsg.Type type = 1;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::logic::PushMsg_Type type() const;
  void set_type(::logic::PushMsg_Type value);

  // optional int32 operation = 2;
  void clear_operation();
  static const int kOperationFieldNumber = 2;
  ::google::protobuf::int32 operation() const;
  void set_operation(::google::protobuf::int32 value);

  // optional int32 speed = 3;
  void clear_speed();
  static const int kSpeedFieldNumber = 3;
  ::google::protobuf::int32 speed() const;
  void set_speed(::google::protobuf::int32 value);

  // optional string server = 4;
  void clear_server();
  static const int kServerFieldNumber = 4;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // optional string room = 5;
  void clear_room();
  static const int kRoomFieldNumber = 5;
  const ::std::string& room() const;
  void set_room(const ::std::string& value);
  void set_room(const char* value);
  void set_room(const char* value, size_t size);
  ::std::string* mutable_room();
  ::std::string* release_room();
  void set_allocated_room(::std::string* room);

  // repeated string keys = 6;
  int keys_size() const;
  void clear_keys();
  static const int kKeysFieldNumber = 6;
  const ::std::string& keys(int index) const;
  ::std::string* mutable_keys(int index);
  void set_keys(int index, const ::std::string& value);
  void set_keys(int index, const char* value);
  void set_keys(int index, const char* value, size_t size);
  ::std::string* add_keys();
  void add_keys(const ::std::string& value);
  void add_keys(const char* value);
  void add_keys(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& keys() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_keys();

  // optional bytes msg = 7;
  void clear_msg();
  static const int kMsgFieldNumber = 7;
  const ::std::string& msg() const;
  void set_msg(const ::std::string& value);
  void set_msg(const char* value);
  void set_msg(const void* value, size_t size);
  ::std::string* mutable_msg();
  ::std::string* release_msg();
  void set_allocated_msg(::std::string* msg);

  // @@protoc_insertion_point(class_scope:logic.PushMsg)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  int type_;
  ::google::protobuf::int32 operation_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::google::protobuf::internal::ArenaStringPtr room_;
  ::google::protobuf::RepeatedPtrField< ::std::string> keys_;
  ::google::protobuf::internal::ArenaStringPtr msg_;
  ::google::protobuf::int32 speed_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static PushMsg* default_instance_;
};
// -------------------------------------------------------------------

class CloseReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.CloseReply) */ {
 public:
  CloseReply();
  virtual ~CloseReply();

  CloseReply(const CloseReply& from);

  inline CloseReply& operator=(const CloseReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseReply& default_instance();

  void Swap(CloseReply* other);

  // implements Message ----------------------------------------------

  inline CloseReply* New() const { return New(NULL); }

  CloseReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseReply& from);
  void MergeFrom(const CloseReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.CloseReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static CloseReply* default_instance_;
};
// -------------------------------------------------------------------

class CloseReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.CloseReq) */ {
 public:
  CloseReq();
  virtual ~CloseReq();

  CloseReq(const CloseReq& from);

  inline CloseReq& operator=(const CloseReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CloseReq& default_instance();

  void Swap(CloseReq* other);

  // implements Message ----------------------------------------------

  inline CloseReq* New() const { return New(NULL); }

  CloseReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CloseReq& from);
  void MergeFrom(const CloseReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CloseReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.CloseReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static CloseReq* default_instance_;
};
// -------------------------------------------------------------------

class PingReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.PingReply) */ {
 public:
  PingReply();
  virtual ~PingReply();

  PingReply(const PingReply& from);

  inline PingReply& operator=(const PingReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingReply& default_instance();

  void Swap(PingReply* other);

  // implements Message ----------------------------------------------

  inline PingReply* New() const { return New(NULL); }

  PingReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingReply& from);
  void MergeFrom(const PingReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.PingReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static PingReply* default_instance_;
};
// -------------------------------------------------------------------

class PingReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.PingReq) */ {
 public:
  PingReq();
  virtual ~PingReq();

  PingReq(const PingReq& from);

  inline PingReq& operator=(const PingReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PingReq& default_instance();

  void Swap(PingReq* other);

  // implements Message ----------------------------------------------

  inline PingReq* New() const { return New(NULL); }

  PingReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PingReq& from);
  void MergeFrom(const PingReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(PingReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.PingReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static PingReq* default_instance_;
};
// -------------------------------------------------------------------

class ConnectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.ConnectReq) */ {
 public:
  ConnectReq();
  virtual ~ConnectReq();

  ConnectReq(const ConnectReq& from);

  inline ConnectReq& operator=(const ConnectReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectReq& default_instance();

  void Swap(ConnectReq* other);

  // implements Message ----------------------------------------------

  inline ConnectReq* New() const { return New(NULL); }

  ConnectReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectReq& from);
  void MergeFrom(const ConnectReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // optional string cookie = 2;
  void clear_cookie();
  static const int kCookieFieldNumber = 2;
  const ::std::string& cookie() const;
  void set_cookie(const ::std::string& value);
  void set_cookie(const char* value);
  void set_cookie(const char* value, size_t size);
  ::std::string* mutable_cookie();
  ::std::string* release_cookie();
  void set_allocated_cookie(::std::string* cookie);

  // optional bytes token = 3;
  void clear_token();
  static const int kTokenFieldNumber = 3;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  void set_token(const char* value);
  void set_token(const void* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:logic.ConnectReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  ::google::protobuf::internal::ArenaStringPtr cookie_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static ConnectReq* default_instance_;
};
// -------------------------------------------------------------------

class ConnectReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.ConnectReply) */ {
 public:
  ConnectReply();
  virtual ~ConnectReply();

  ConnectReply(const ConnectReply& from);

  inline ConnectReply& operator=(const ConnectReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConnectReply& default_instance();

  void Swap(ConnectReply* other);

  // implements Message ----------------------------------------------

  inline ConnectReply* New() const { return New(NULL); }

  ConnectReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConnectReply& from);
  void MergeFrom(const ConnectReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ConnectReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 mid = 1;
  void clear_mid();
  static const int kMidFieldNumber = 1;
  ::google::protobuf::int64 mid() const;
  void set_mid(::google::protobuf::int64 value);

  // optional string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string roomID = 3;
  void clear_roomid();
  static const int kRoomIDFieldNumber = 3;
  const ::std::string& roomid() const;
  void set_roomid(const ::std::string& value);
  void set_roomid(const char* value);
  void set_roomid(const char* value, size_t size);
  ::std::string* mutable_roomid();
  ::std::string* release_roomid();
  void set_allocated_roomid(::std::string* roomid);

  // repeated int32 accepts = 4;
  int accepts_size() const;
  void clear_accepts();
  static const int kAcceptsFieldNumber = 4;
  ::google::protobuf::int32 accepts(int index) const;
  void set_accepts(int index, ::google::protobuf::int32 value);
  void add_accepts(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      accepts() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_accepts();

  // optional int64 heartbeat = 5;
  void clear_heartbeat();
  static const int kHeartbeatFieldNumber = 5;
  ::google::protobuf::int64 heartbeat() const;
  void set_heartbeat(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:logic.ConnectReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 mid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr roomid_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > accepts_;
  mutable int _accepts_cached_byte_size_;
  ::google::protobuf::int64 heartbeat_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static ConnectReply* default_instance_;
};
// -------------------------------------------------------------------

class DisconnectReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.DisconnectReq) */ {
 public:
  DisconnectReq();
  virtual ~DisconnectReq();

  DisconnectReq(const DisconnectReq& from);

  inline DisconnectReq& operator=(const DisconnectReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectReq& default_instance();

  void Swap(DisconnectReq* other);

  // implements Message ----------------------------------------------

  inline DisconnectReq* New() const { return New(NULL); }

  DisconnectReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisconnectReq& from);
  void MergeFrom(const DisconnectReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisconnectReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 mid = 1;
  void clear_mid();
  static const int kMidFieldNumber = 1;
  ::google::protobuf::int64 mid() const;
  void set_mid(::google::protobuf::int64 value);

  // optional string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string server = 3;
  void clear_server();
  static const int kServerFieldNumber = 3;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:logic.DisconnectReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 mid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static DisconnectReq* default_instance_;
};
// -------------------------------------------------------------------

class DisconnectReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.DisconnectReply) */ {
 public:
  DisconnectReply();
  virtual ~DisconnectReply();

  DisconnectReply(const DisconnectReply& from);

  inline DisconnectReply& operator=(const DisconnectReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DisconnectReply& default_instance();

  void Swap(DisconnectReply* other);

  // implements Message ----------------------------------------------

  inline DisconnectReply* New() const { return New(NULL); }

  DisconnectReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DisconnectReply& from);
  void MergeFrom(const DisconnectReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DisconnectReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool has = 1;
  void clear_has();
  static const int kHasFieldNumber = 1;
  bool has() const;
  void set_has(bool value);

  // @@protoc_insertion_point(class_scope:logic.DisconnectReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  bool has_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static DisconnectReply* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.HeartbeatReq) */ {
 public:
  HeartbeatReq();
  virtual ~HeartbeatReq();

  HeartbeatReq(const HeartbeatReq& from);

  inline HeartbeatReq& operator=(const HeartbeatReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReq& default_instance();

  void Swap(HeartbeatReq* other);

  // implements Message ----------------------------------------------

  inline HeartbeatReq* New() const { return New(NULL); }

  HeartbeatReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatReq& from);
  void MergeFrom(const HeartbeatReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 mid = 1;
  void clear_mid();
  static const int kMidFieldNumber = 1;
  ::google::protobuf::int64 mid() const;
  void set_mid(::google::protobuf::int64 value);

  // optional string key = 2;
  void clear_key();
  static const int kKeyFieldNumber = 2;
  const ::std::string& key() const;
  void set_key(const ::std::string& value);
  void set_key(const char* value);
  void set_key(const char* value, size_t size);
  ::std::string* mutable_key();
  ::std::string* release_key();
  void set_allocated_key(::std::string* key);

  // optional string server = 3;
  void clear_server();
  static const int kServerFieldNumber = 3;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // @@protoc_insertion_point(class_scope:logic.HeartbeatReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 mid_;
  ::google::protobuf::internal::ArenaStringPtr key_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatReq* default_instance_;
};
// -------------------------------------------------------------------

class HeartbeatReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.HeartbeatReply) */ {
 public:
  HeartbeatReply();
  virtual ~HeartbeatReply();

  HeartbeatReply(const HeartbeatReply& from);

  inline HeartbeatReply& operator=(const HeartbeatReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HeartbeatReply& default_instance();

  void Swap(HeartbeatReply* other);

  // implements Message ----------------------------------------------

  inline HeartbeatReply* New() const { return New(NULL); }

  HeartbeatReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HeartbeatReply& from);
  void MergeFrom(const HeartbeatReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(HeartbeatReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.HeartbeatReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static HeartbeatReply* default_instance_;
};
// -------------------------------------------------------------------

class OnlineReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.OnlineReq) */ {
 public:
  OnlineReq();
  virtual ~OnlineReq();

  OnlineReq(const OnlineReq& from);

  inline OnlineReq& operator=(const OnlineReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineReq& default_instance();

  void Swap(OnlineReq* other);

  // implements Message ----------------------------------------------

  inline OnlineReq* New() const { return New(NULL); }

  OnlineReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineReq& from);
  void MergeFrom(const OnlineReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnlineReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // optional string server = 1;
  void clear_server();
  static const int kServerFieldNumber = 1;
  const ::std::string& server() const;
  void set_server(const ::std::string& value);
  void set_server(const char* value);
  void set_server(const char* value, size_t size);
  ::std::string* mutable_server();
  ::std::string* release_server();
  void set_allocated_server(::std::string* server);

  // map<string, int32> roomCount = 2;
  int roomcount_size() const;
  void clear_roomcount();
  static const int kRoomCountFieldNumber = 2;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      roomcount() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_roomcount();

  // @@protoc_insertion_point(class_scope:logic.OnlineReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr server_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 >
      OnlineReq_RoomCountEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > roomcount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static OnlineReq* default_instance_;
};
// -------------------------------------------------------------------

class OnlineReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.OnlineReply) */ {
 public:
  OnlineReply();
  virtual ~OnlineReply();

  OnlineReply(const OnlineReply& from);

  inline OnlineReply& operator=(const OnlineReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OnlineReply& default_instance();

  void Swap(OnlineReply* other);

  // implements Message ----------------------------------------------

  inline OnlineReply* New() const { return New(NULL); }

  OnlineReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OnlineReply& from);
  void MergeFrom(const OnlineReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OnlineReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  // map<string, int32> allRoomCount = 1;
  int allroomcount_size() const;
  void clear_allroomcount();
  static const int kAllRoomCountFieldNumber = 1;
  const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
      allroomcount() const;
  ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
      mutable_allroomcount();

  // @@protoc_insertion_point(class_scope:logic.OnlineReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  typedef ::google::protobuf::internal::MapEntryLite<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 >
      OnlineReply_AllRoomCountEntry;
  ::google::protobuf::internal::MapField<
      ::std::string, ::google::protobuf::int32,
      ::google::protobuf::internal::WireFormatLite::TYPE_STRING,
      ::google::protobuf::internal::WireFormatLite::TYPE_INT32,
      0 > allroomcount_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static OnlineReply* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveReq : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.ReceiveReq) */ {
 public:
  ReceiveReq();
  virtual ~ReceiveReq();

  ReceiveReq(const ReceiveReq& from);

  inline ReceiveReq& operator=(const ReceiveReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveReq& default_instance();

  void Swap(ReceiveReq* other);

  // implements Message ----------------------------------------------

  inline ReceiveReq* New() const { return New(NULL); }

  ReceiveReq* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveReq& from);
  void MergeFrom(const ReceiveReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveReq* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 mid = 1;
  void clear_mid();
  static const int kMidFieldNumber = 1;
  ::google::protobuf::int64 mid() const;
  void set_mid(::google::protobuf::int64 value);

  // optional .gate.Proto proto = 2;
  bool has_proto() const;
  void clear_proto();
  static const int kProtoFieldNumber = 2;
  const ::gate::Proto& proto() const;
  ::gate::Proto* mutable_proto();
  ::gate::Proto* release_proto();
  void set_allocated_proto(::gate::Proto* proto);

  // @@protoc_insertion_point(class_scope:logic.ReceiveReq)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::int64 mid_;
  ::gate::Proto* proto_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static ReceiveReq* default_instance_;
};
// -------------------------------------------------------------------

class ReceiveReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:logic.ReceiveReply) */ {
 public:
  ReceiveReply();
  virtual ~ReceiveReply();

  ReceiveReply(const ReceiveReply& from);

  inline ReceiveReply& operator=(const ReceiveReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReceiveReply& default_instance();

  void Swap(ReceiveReply* other);

  // implements Message ----------------------------------------------

  inline ReceiveReply* New() const { return New(NULL); }

  ReceiveReply* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReceiveReply& from);
  void MergeFrom(const ReceiveReply& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ReceiveReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:logic.ReceiveReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_logic_2eproto();
  friend void protobuf_AssignDesc_logic_2eproto();
  friend void protobuf_ShutdownFile_logic_2eproto();

  void InitAsDefaultInstance();
  static ReceiveReply* default_instance_;
};
// ===================================================================

class Logic_Stub;

class Logic : public ::google::protobuf::Service {
 protected:
  // This class should be treated as an abstract interface.
  inline Logic() {};
 public:
  virtual ~Logic();

  typedef Logic_Stub Stub;

  static const ::google::protobuf::ServiceDescriptor* descriptor();

  virtual void Ping(::google::protobuf::RpcController* controller,
                       const ::logic::PingReq* request,
                       ::logic::PingReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Close(::google::protobuf::RpcController* controller,
                       const ::logic::CloseReq* request,
                       ::logic::CloseReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Connect(::google::protobuf::RpcController* controller,
                       const ::logic::ConnectReq* request,
                       ::logic::ConnectReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Disconnect(::google::protobuf::RpcController* controller,
                       const ::logic::DisconnectReq* request,
                       ::logic::DisconnectReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Heartbeat(::google::protobuf::RpcController* controller,
                       const ::logic::HeartbeatReq* request,
                       ::logic::HeartbeatReply* response,
                       ::google::protobuf::Closure* done);
  virtual void RenewOnline(::google::protobuf::RpcController* controller,
                       const ::logic::OnlineReq* request,
                       ::logic::OnlineReply* response,
                       ::google::protobuf::Closure* done);
  virtual void Receive(::google::protobuf::RpcController* controller,
                       const ::logic::ReceiveReq* request,
                       ::logic::ReceiveReply* response,
                       ::google::protobuf::Closure* done);

  // implements Service ----------------------------------------------

  const ::google::protobuf::ServiceDescriptor* GetDescriptor();
  void CallMethod(const ::google::protobuf::MethodDescriptor* method,
                  ::google::protobuf::RpcController* controller,
                  const ::google::protobuf::Message* request,
                  ::google::protobuf::Message* response,
                  ::google::protobuf::Closure* done);
  const ::google::protobuf::Message& GetRequestPrototype(
    const ::google::protobuf::MethodDescriptor* method) const;
  const ::google::protobuf::Message& GetResponsePrototype(
    const ::google::protobuf::MethodDescriptor* method) const;

 private:
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Logic);
};

class Logic_Stub : public Logic {
 public:
  Logic_Stub(::google::protobuf::RpcChannel* channel);
  Logic_Stub(::google::protobuf::RpcChannel* channel,
                   ::google::protobuf::Service::ChannelOwnership ownership);
  ~Logic_Stub();

  inline ::google::protobuf::RpcChannel* channel() { return channel_; }

  // implements Logic ------------------------------------------

  void Ping(::google::protobuf::RpcController* controller,
                       const ::logic::PingReq* request,
                       ::logic::PingReply* response,
                       ::google::protobuf::Closure* done);
  void Close(::google::protobuf::RpcController* controller,
                       const ::logic::CloseReq* request,
                       ::logic::CloseReply* response,
                       ::google::protobuf::Closure* done);
  void Connect(::google::protobuf::RpcController* controller,
                       const ::logic::ConnectReq* request,
                       ::logic::ConnectReply* response,
                       ::google::protobuf::Closure* done);
  void Disconnect(::google::protobuf::RpcController* controller,
                       const ::logic::DisconnectReq* request,
                       ::logic::DisconnectReply* response,
                       ::google::protobuf::Closure* done);
  void Heartbeat(::google::protobuf::RpcController* controller,
                       const ::logic::HeartbeatReq* request,
                       ::logic::HeartbeatReply* response,
                       ::google::protobuf::Closure* done);
  void RenewOnline(::google::protobuf::RpcController* controller,
                       const ::logic::OnlineReq* request,
                       ::logic::OnlineReply* response,
                       ::google::protobuf::Closure* done);
  void Receive(::google::protobuf::RpcController* controller,
                       const ::logic::ReceiveReq* request,
                       ::logic::ReceiveReply* response,
                       ::google::protobuf::Closure* done);
 private:
  ::google::protobuf::RpcChannel* channel_;
  bool owns_channel_;
  GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Logic_Stub);
};


// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// PushMsg

// optional .logic.PushMsg.Type type = 1;
inline void PushMsg::clear_type() {
  type_ = 0;
}
inline ::logic::PushMsg_Type PushMsg::type() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.type)
  return static_cast< ::logic::PushMsg_Type >(type_);
}
inline void PushMsg::set_type(::logic::PushMsg_Type value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.type)
}

// optional int32 operation = 2;
inline void PushMsg::clear_operation() {
  operation_ = 0;
}
inline ::google::protobuf::int32 PushMsg::operation() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.operation)
  return operation_;
}
inline void PushMsg::set_operation(::google::protobuf::int32 value) {
  
  operation_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.operation)
}

// optional int32 speed = 3;
inline void PushMsg::clear_speed() {
  speed_ = 0;
}
inline ::google::protobuf::int32 PushMsg::speed() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.speed)
  return speed_;
}
inline void PushMsg::set_speed(::google::protobuf::int32 value) {
  
  speed_ = value;
  // @@protoc_insertion_point(field_set:logic.PushMsg.speed)
}

// optional string server = 4;
inline void PushMsg::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushMsg::server() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.server)
}
inline void PushMsg::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.server)
}
inline void PushMsg::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.server)
}
inline ::std::string* PushMsg::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushMsg::release_server() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.server)
}

// optional string room = 5;
inline void PushMsg::clear_room() {
  room_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushMsg::room() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.room)
  return room_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_room(const ::std::string& value) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.room)
}
inline void PushMsg::set_room(const char* value) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.room)
}
inline void PushMsg::set_room(const char* value, size_t size) {
  
  room_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.room)
}
inline ::std::string* PushMsg::mutable_room() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.room)
  return room_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushMsg::release_room() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.room)
  
  return room_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_allocated_room(::std::string* room) {
  if (room != NULL) {
    
  } else {
    
  }
  room_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), room);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.room)
}

// repeated string keys = 6;
inline int PushMsg::keys_size() const {
  return keys_.size();
}
inline void PushMsg::clear_keys() {
  keys_.Clear();
}
inline const ::std::string& PushMsg::keys(int index) const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.keys)
  return keys_.Get(index);
}
inline ::std::string* PushMsg::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.keys)
  return keys_.Mutable(index);
}
inline void PushMsg::set_keys(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:logic.PushMsg.keys)
  keys_.Mutable(index)->assign(value);
}
inline void PushMsg::set_keys(int index, const char* value) {
  keys_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.keys)
}
inline void PushMsg::set_keys(int index, const char* value, size_t size) {
  keys_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.keys)
}
inline ::std::string* PushMsg::add_keys() {
  // @@protoc_insertion_point(field_add_mutable:logic.PushMsg.keys)
  return keys_.Add();
}
inline void PushMsg::add_keys(const ::std::string& value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:logic.PushMsg.keys)
}
inline void PushMsg::add_keys(const char* value) {
  keys_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:logic.PushMsg.keys)
}
inline void PushMsg::add_keys(const char* value, size_t size) {
  keys_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:logic.PushMsg.keys)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
PushMsg::keys() const {
  // @@protoc_insertion_point(field_list:logic.PushMsg.keys)
  return keys_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
PushMsg::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:logic.PushMsg.keys)
  return &keys_;
}

// optional bytes msg = 7;
inline void PushMsg::clear_msg() {
  msg_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& PushMsg::msg() const {
  // @@protoc_insertion_point(field_get:logic.PushMsg.msg)
  return msg_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_msg(const ::std::string& value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.PushMsg.msg)
}
inline void PushMsg::set_msg(const char* value) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.PushMsg.msg)
}
inline void PushMsg::set_msg(const void* value, size_t size) {
  
  msg_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.PushMsg.msg)
}
inline ::std::string* PushMsg::mutable_msg() {
  
  // @@protoc_insertion_point(field_mutable:logic.PushMsg.msg)
  return msg_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* PushMsg::release_msg() {
  // @@protoc_insertion_point(field_release:logic.PushMsg.msg)
  
  return msg_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void PushMsg::set_allocated_msg(::std::string* msg) {
  if (msg != NULL) {
    
  } else {
    
  }
  msg_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), msg);
  // @@protoc_insertion_point(field_set_allocated:logic.PushMsg.msg)
}

// -------------------------------------------------------------------

// CloseReply

// -------------------------------------------------------------------

// CloseReq

// -------------------------------------------------------------------

// PingReply

// -------------------------------------------------------------------

// PingReq

// -------------------------------------------------------------------

// ConnectReq

// optional string server = 1;
inline void ConnectReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectReq::server() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.server)
}
inline void ConnectReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.server)
}
inline void ConnectReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.server)
}
inline ::std::string* ConnectReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.server)
}

// optional string cookie = 2;
inline void ConnectReq::clear_cookie() {
  cookie_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectReq::cookie() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.cookie)
  return cookie_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_cookie(const ::std::string& value) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.cookie)
}
inline void ConnectReq::set_cookie(const char* value) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.cookie)
}
inline void ConnectReq::set_cookie(const char* value, size_t size) {
  
  cookie_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.cookie)
}
inline ::std::string* ConnectReq::mutable_cookie() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.cookie)
  return cookie_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_cookie() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.cookie)
  
  return cookie_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_cookie(::std::string* cookie) {
  if (cookie != NULL) {
    
  } else {
    
  }
  cookie_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cookie);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.cookie)
}

// optional bytes token = 3;
inline void ConnectReq::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectReq::token() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReq.token)
  return token_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReq.token)
}
inline void ConnectReq::set_token(const char* value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReq.token)
}
inline void ConnectReq::set_token(const void* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReq.token)
}
inline ::std::string* ConnectReq::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReq.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReq::release_token() {
  // @@protoc_insertion_point(field_release:logic.ConnectReq.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReq::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReq.token)
}

// -------------------------------------------------------------------

// ConnectReply

// optional int64 mid = 1;
inline void ConnectReply::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConnectReply::mid() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.mid)
  return mid_;
}
inline void ConnectReply::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.ConnectReply.mid)
}

// optional string key = 2;
inline void ConnectReply::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectReply::key() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReply::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.key)
}
inline void ConnectReply::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReply.key)
}
inline void ConnectReply::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReply.key)
}
inline ::std::string* ConnectReply::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReply.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReply::release_key() {
  // @@protoc_insertion_point(field_release:logic.ConnectReply.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReply::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReply.key)
}

// optional string roomID = 3;
inline void ConnectReply::clear_roomid() {
  roomid_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ConnectReply::roomid() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.roomID)
  return roomid_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReply::set_roomid(const ::std::string& value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.roomID)
}
inline void ConnectReply::set_roomid(const char* value) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.ConnectReply.roomID)
}
inline void ConnectReply::set_roomid(const char* value, size_t size) {
  
  roomid_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.ConnectReply.roomID)
}
inline ::std::string* ConnectReply::mutable_roomid() {
  
  // @@protoc_insertion_point(field_mutable:logic.ConnectReply.roomID)
  return roomid_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ConnectReply::release_roomid() {
  // @@protoc_insertion_point(field_release:logic.ConnectReply.roomID)
  
  return roomid_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ConnectReply::set_allocated_roomid(::std::string* roomid) {
  if (roomid != NULL) {
    
  } else {
    
  }
  roomid_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), roomid);
  // @@protoc_insertion_point(field_set_allocated:logic.ConnectReply.roomID)
}

// repeated int32 accepts = 4;
inline int ConnectReply::accepts_size() const {
  return accepts_.size();
}
inline void ConnectReply::clear_accepts() {
  accepts_.Clear();
}
inline ::google::protobuf::int32 ConnectReply::accepts(int index) const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.accepts)
  return accepts_.Get(index);
}
inline void ConnectReply::set_accepts(int index, ::google::protobuf::int32 value) {
  accepts_.Set(index, value);
  // @@protoc_insertion_point(field_set:logic.ConnectReply.accepts)
}
inline void ConnectReply::add_accepts(::google::protobuf::int32 value) {
  accepts_.Add(value);
  // @@protoc_insertion_point(field_add:logic.ConnectReply.accepts)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ConnectReply::accepts() const {
  // @@protoc_insertion_point(field_list:logic.ConnectReply.accepts)
  return accepts_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ConnectReply::mutable_accepts() {
  // @@protoc_insertion_point(field_mutable_list:logic.ConnectReply.accepts)
  return &accepts_;
}

// optional int64 heartbeat = 5;
inline void ConnectReply::clear_heartbeat() {
  heartbeat_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ConnectReply::heartbeat() const {
  // @@protoc_insertion_point(field_get:logic.ConnectReply.heartbeat)
  return heartbeat_;
}
inline void ConnectReply::set_heartbeat(::google::protobuf::int64 value) {
  
  heartbeat_ = value;
  // @@protoc_insertion_point(field_set:logic.ConnectReply.heartbeat)
}

// -------------------------------------------------------------------

// DisconnectReq

// optional int64 mid = 1;
inline void DisconnectReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 DisconnectReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.mid)
  return mid_;
}
inline void DisconnectReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.mid)
}

// optional string key = 2;
inline void DisconnectReq::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DisconnectReq::key() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisconnectReq::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.key)
}
inline void DisconnectReq::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.DisconnectReq.key)
}
inline void DisconnectReq::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.DisconnectReq.key)
}
inline ::std::string* DisconnectReq::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.DisconnectReq.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisconnectReq::release_key() {
  // @@protoc_insertion_point(field_release:logic.DisconnectReq.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisconnectReq::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.DisconnectReq.key)
}

// optional string server = 3;
inline void DisconnectReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& DisconnectReq::server() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisconnectReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.DisconnectReq.server)
}
inline void DisconnectReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.DisconnectReq.server)
}
inline void DisconnectReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.DisconnectReq.server)
}
inline ::std::string* DisconnectReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.DisconnectReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DisconnectReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.DisconnectReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DisconnectReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.DisconnectReq.server)
}

// -------------------------------------------------------------------

// DisconnectReply

// optional bool has = 1;
inline void DisconnectReply::clear_has() {
  has_ = false;
}
inline bool DisconnectReply::has() const {
  // @@protoc_insertion_point(field_get:logic.DisconnectReply.has)
  return has_;
}
inline void DisconnectReply::set_has(bool value) {
  
  has_ = value;
  // @@protoc_insertion_point(field_set:logic.DisconnectReply.has)
}

// -------------------------------------------------------------------

// HeartbeatReq

// optional int64 mid = 1;
inline void HeartbeatReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 HeartbeatReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.mid)
  return mid_;
}
inline void HeartbeatReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.mid)
}

// optional string key = 2;
inline void HeartbeatReq::clear_key() {
  key_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeartbeatReq::key() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.key)
  return key_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatReq::set_key(const ::std::string& value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.key)
}
inline void HeartbeatReq::set_key(const char* value) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.HeartbeatReq.key)
}
inline void HeartbeatReq::set_key(const char* value, size_t size) {
  
  key_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.HeartbeatReq.key)
}
inline ::std::string* HeartbeatReq::mutable_key() {
  
  // @@protoc_insertion_point(field_mutable:logic.HeartbeatReq.key)
  return key_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartbeatReq::release_key() {
  // @@protoc_insertion_point(field_release:logic.HeartbeatReq.key)
  
  return key_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatReq::set_allocated_key(::std::string* key) {
  if (key != NULL) {
    
  } else {
    
  }
  key_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), key);
  // @@protoc_insertion_point(field_set_allocated:logic.HeartbeatReq.key)
}

// optional string server = 3;
inline void HeartbeatReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& HeartbeatReq::server() const {
  // @@protoc_insertion_point(field_get:logic.HeartbeatReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.HeartbeatReq.server)
}
inline void HeartbeatReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.HeartbeatReq.server)
}
inline void HeartbeatReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.HeartbeatReq.server)
}
inline ::std::string* HeartbeatReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.HeartbeatReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* HeartbeatReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.HeartbeatReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void HeartbeatReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.HeartbeatReq.server)
}

// -------------------------------------------------------------------

// HeartbeatReply

// -------------------------------------------------------------------

// OnlineReq

// optional string server = 1;
inline void OnlineReq::clear_server() {
  server_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OnlineReq::server() const {
  // @@protoc_insertion_point(field_get:logic.OnlineReq.server)
  return server_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnlineReq::set_server(const ::std::string& value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:logic.OnlineReq.server)
}
inline void OnlineReq::set_server(const char* value) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:logic.OnlineReq.server)
}
inline void OnlineReq::set_server(const char* value, size_t size) {
  
  server_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:logic.OnlineReq.server)
}
inline ::std::string* OnlineReq::mutable_server() {
  
  // @@protoc_insertion_point(field_mutable:logic.OnlineReq.server)
  return server_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OnlineReq::release_server() {
  // @@protoc_insertion_point(field_release:logic.OnlineReq.server)
  
  return server_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OnlineReq::set_allocated_server(::std::string* server) {
  if (server != NULL) {
    
  } else {
    
  }
  server_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), server);
  // @@protoc_insertion_point(field_set_allocated:logic.OnlineReq.server)
}

// map<string, int32> roomCount = 2;
inline int OnlineReq::roomcount_size() const {
  return roomcount_.size();
}
inline void OnlineReq::clear_roomcount() {
  roomcount_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
OnlineReq::roomcount() const {
  // @@protoc_insertion_point(field_map:logic.OnlineReq.roomCount)
  return roomcount_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
OnlineReq::mutable_roomcount() {
  // @@protoc_insertion_point(field_mutable_map:logic.OnlineReq.roomCount)
  return roomcount_.MutableMap();
}

// -------------------------------------------------------------------

// OnlineReply

// map<string, int32> allRoomCount = 1;
inline int OnlineReply::allroomcount_size() const {
  return allroomcount_.size();
}
inline void OnlineReply::clear_allroomcount() {
  allroomcount_.Clear();
}
inline const ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >&
OnlineReply::allroomcount() const {
  // @@protoc_insertion_point(field_map:logic.OnlineReply.allRoomCount)
  return allroomcount_.GetMap();
}
inline ::google::protobuf::Map< ::std::string, ::google::protobuf::int32 >*
OnlineReply::mutable_allroomcount() {
  // @@protoc_insertion_point(field_mutable_map:logic.OnlineReply.allRoomCount)
  return allroomcount_.MutableMap();
}

// -------------------------------------------------------------------

// ReceiveReq

// optional int64 mid = 1;
inline void ReceiveReq::clear_mid() {
  mid_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 ReceiveReq::mid() const {
  // @@protoc_insertion_point(field_get:logic.ReceiveReq.mid)
  return mid_;
}
inline void ReceiveReq::set_mid(::google::protobuf::int64 value) {
  
  mid_ = value;
  // @@protoc_insertion_point(field_set:logic.ReceiveReq.mid)
}

// optional .gate.Proto proto = 2;
inline bool ReceiveReq::has_proto() const {
  return !_is_default_instance_ && proto_ != NULL;
}
inline void ReceiveReq::clear_proto() {
  if (GetArenaNoVirtual() == NULL && proto_ != NULL) delete proto_;
  proto_ = NULL;
}
inline const ::gate::Proto& ReceiveReq::proto() const {
  // @@protoc_insertion_point(field_get:logic.ReceiveReq.proto)
  return proto_ != NULL ? *proto_ : *default_instance_->proto_;
}
inline ::gate::Proto* ReceiveReq::mutable_proto() {
  
  if (proto_ == NULL) {
    proto_ = new ::gate::Proto;
  }
  // @@protoc_insertion_point(field_mutable:logic.ReceiveReq.proto)
  return proto_;
}
inline ::gate::Proto* ReceiveReq::release_proto() {
  // @@protoc_insertion_point(field_release:logic.ReceiveReq.proto)
  
  ::gate::Proto* temp = proto_;
  proto_ = NULL;
  return temp;
}
inline void ReceiveReq::set_allocated_proto(::gate::Proto* proto) {
  delete proto_;
  proto_ = proto;
  if (proto) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:logic.ReceiveReq.proto)
}

// -------------------------------------------------------------------

// ReceiveReply

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace logic

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::logic::PushMsg_Type> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::logic::PushMsg_Type>() {
  return ::logic::PushMsg_Type_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_logic_2eproto__INCLUDED
